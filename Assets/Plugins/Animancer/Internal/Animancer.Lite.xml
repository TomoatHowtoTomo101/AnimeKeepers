<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Animancer.Lite</name>
    </assembly>
    <members>
        <member name="T:Animancer.AnimancerLayer">
            <summary>
            A layer on which animations can play with their states managed independantly of other layers while blending the
            output with those layers.
            <para></para>
            This class can be used as a custom yield instruction to wait until all animations finish playing.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.Layer">
            <summary>A layer is its own root.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.Parent">
            <summary>Returns null because layers always connect to the <see cref="F:Animancer.AnimancerNode.Root"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ParentPlayable">
            <summary>The <see cref="!:Root"/>'s <see cref="T:UnityEngine.Animations.AnimationLayerMixerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.KeepChildrenConnected">
            <summary>Indicates whether child playables should stay connected to this mixer at all times.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.StayConnectedWhenWeightless">
            <summary>The <see cref="!:Root"/>'s <see cref="!:AnimancerNode.KeepPlayablesConnected"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.CurrentState">
            <summary>
            The state of the animation currently being played.
            <para></para>
            Specifically, this is the state that was most recently started using any of the Play or CrossFade methods
            on this layer. States controlled individually via methods in the <see cref="T:Animancer.AnimancerState"/> itself will
            not register in this property.
            <para></para>
            Each time this property changes, the <see cref="P:Animancer.AnimancerLayer.CurrentStateID"/> is incremented.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.CurrentStateID">
            <summary>
            The number of times the <see cref="P:Animancer.AnimancerLayer.CurrentState"/> has changed. By storing this value and later comparing
            the stored value to the current value, you can determine whether the state has been changed since then,
            even if the actual state is the same.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerLayer.States">
            <summary>All of the animation states connected to the <see cref="!:_Mixer"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.#ctor(Animancer.AnimancerPlayable,System.Int32)">
            <summary>[Internal]
            Constructs a new <see cref="T:Animancer.AnimancerLayer"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.IsAdditive">
            <summary>[Pro-Only]
            Determines whether this layer is set to additive blending. Otherwise it will override any earlier layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.SetMask(UnityEngine.AvatarMask)">
            <summary>[Pro-Only]
            Sets an <see cref="T:UnityEngine.AvatarMask"/> to determine which bones this layer will affect.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.DestroyStates">
            <summary>
            Destroys all states connected to this layer. This operation cannot be undone.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ChildCount">
            <summary>The number of states using this layer as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetChild(System.Int32)">
            <summary>
            Returns the state connected to the specified 'portIndex' as a child of this layer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.AddChild(Animancer.AnimancerState)">
            <summary>
            Adds a new port and uses <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> to connect the 'state' to it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnAddChild(Animancer.AnimancerState)">
            <summary>Connects the 'state' to this layer at its <see cref="P:Animancer.AnimancerNode.PortIndex"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnRemoveChild(Animancer.AnimancerState)">
            <summary>Disconnects the 'state' from this layer at its <see cref="P:Animancer.AnimancerNode.PortIndex"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.ValidateState(Animancer.AnimancerState)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if the <see cref="P:Animancer.AnimancerState.Parent"/> is not this
            <see cref="T:Animancer.AnimancerLayer"/>.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetEnumerator">
            <summary>
            Returns an enumerator that will iterate through all states connected directly to this layer (not inside
            <see cref="T:Animancer.MixerState"/>s).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsPlayingAndNotEnding">
            <summary>
            Returns true if the <see cref="P:Animancer.AnimancerLayer.CurrentState"/> is playing and hasn't yet reached its end.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't have a length, as indicated by
            <see cref="!:HasLength"/>.</exception>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnStartFade">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/> (when this layer starts fading, not when one of its states
            starts fading). Clears the <see cref="P:Animancer.AnimancerState.OnEnd"/> events of all states.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)">
            <summary>
            Stops all other animations, plays the 'state', and returns it.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the 'state's time to 0.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CrossFade(Animancer.AnimancerState,System.Single)">
            <summary>
            Starts fading in the 'state' over the course of the 'fadeDuration' while fading out all others in this
            layer. Returns the 'state'.
            <para></para>
            If the 'state' was already playing, it will continue doing so from the current time, unlike
            <see cref="M:Animancer.AnimancerLayer.CrossFadeFromStart(Animancer.AnimancerState,System.Single)"/>.
            <para></para>
            If the 'state' was already playing and fading in with less time remaining than the 'fadeDuration', this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If this layer currently has 0 <see cref="!:Weight"/>, this method will instead start fading in the layer
            itself and simply <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)"/> the 'state'.
            <para></para>
            Animancer Lite only allows the default 'fadeDuration' (0.3 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CrossFadeFromStart(Animancer.AnimancerState,System.Single)">
            <summary>
            Starts fading in the 'state' from the start over the course of the 'fadeDuration' while fading out all
            others in this layer. Returns the 'state'.
            <para></para>
            If the 'state' isn't currently at 0 <see cref="!:AnimancerState.Weight"/>, this method will actually fade it
            to 0 along with the others and create and return a new state with the same clip to fade to 1. This ensures
            that calling this method will always fade out from all current states and fade in from the start of the
            desired animation. States created for this purpose are cached so they can be reused in the future.
            <para></para>
            Calling this method repeatedly on subsequent frames will probably have undesirable effects; you most likely
            want to use <see cref="M:Animancer.AnimancerLayer.CrossFade(Animancer.AnimancerState,System.Single)"/> instead.
            <para></para>
            If this layer currently has 0 <see cref="!:Weight"/>, this method will instead start fading in the layer
            itself and simply <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)"/> the 'state'.
            <para></para>
            Animancer Lite only allows the default 'fadeDuration' (0.3 seconds) in a runtime build.
            </summary>
            <remarks>
            This can be useful when you want to repeat an action while the previous animation is still fading out.
            For example, if you play an 'Attack' animation, it ends and starts fading back to 'Idle', and while it is
            doing so you want to start another 'Attack'. The previous 'Attack' can't simply snap back to the start, so
            you can use this method to create a second 'Attack' state to fade in while the old one fades out.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.Stop">
            <summary>
            Sets <see cref="!:Weight"/> = 0 and calls <see cref="M:Animancer.AnimancerState.Stop"/> on all animations to stop them
            from playing and rewind them to the start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsPlayingClip(UnityEngine.AnimationClip)">
            <summary>
            Returns true if the 'clip' is currently being played by at least one state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsPlaying">
            <summary>
            Returns true if at least one animation is being played.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetTotalWeight">
            <summary>
            Calculates the total <see cref="!:AnimancerState.Weight"/> of all states in this layer.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.AverageVelocity">
            <summary>
            The average velocity of the root motion of all currently playing animations, taking their current
            <see cref="!:AnimancerState.Weight"/> into account.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.TryInvokeOnEndEvent(UnityEngine.AnimationEvent)">
            <summary>
            Invokes the <see cref="P:Animancer.AnimancerState.OnEnd"/> event of the state that is playing the animation which
            triggered the event. Returns true if such a state exists (even if it doesn't have a callback registered).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK">
            <summary>
            Determines the default value of <see cref="P:Animancer.AnimancerState.ApplyAnimatorIK"/> for all new states created in
            this layer. Default false.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while at least one state was at
            <see cref="!:AnimancerState.Weight"/> = 1 which meant that IK would not work while fading between animations.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ApplyAnimatorIK">
            <summary>
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object for any <see cref="F:Animancer.AnimancerLayer.States"/>.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK"/> when a new state is created.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while at least one state was at
            <see cref="!:AnimancerState.Weight"/> = 1 which meant that IK would not work while fading between animations.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.DefaultApplyFootIK">
            <summary>
            Determines the default value of <see cref="P:Animancer.AnimancerState.ApplyFootIK"/> for all new states created in this
            layer. Default false.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ApplyFootIK">
            <summary>
            Determines whether any of the <see cref="F:Animancer.AnimancerLayer.States"/> in this layer are applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyFootIK"/> when a new state is created.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states (applied to the whole layer).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.ToString">
            <summary>Returns a short description of this layer.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipSource"/>]
            Gathers all the animations in this layer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Returns a user-friendly key to identify the 'state' in the inspector.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.SetName(System.String)">
            <summary>[Editor-Conditional]
            Sets the inspector display name of this layer. Note that layer names are Editor-Only so any calls to this
            method will automatically be compiled out of a runtime build.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerNode">
            <summary>
            Base class for <see cref="N:Animancer"/> objects with a <see cref="P:Animancer.AnimancerNode.Weight"/> the can fade over time.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerNode._Playable">
            <summary>
            The internal struct this state manages in the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            <para></para>
            Should be set in the child class constructor. Failure to do so will throw the following exception
            throughout the system when using this node: "<see cref="T:System.ArgumentException"/>: The playable passed as an
            argument is invalid. To create a valid playable, please use the appropriate Create method".
            </summary>
        </member>
        <member name="F:Animancer.AnimancerNode.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Layer">
            <summary>The root <see cref="T:Animancer.AnimancerLayer"/> which this node is connected to.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Parent">
            <summary>
            The node which receives the output of this node.
            <para></para>
            If this is an <see cref="T:Animancer.AnimancerLayer"/> connected to the root <see cref="T:Animancer.AnimancerPlayable"/> it will
            not have a <see cref="P:Animancer.AnimancerNode.Parent"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ParentPlayable">
            <summary>The parent's <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.StayConnectedWhenWeightless">
            <summary>The parent's <see cref="P:Animancer.AnimancerNode.KeepChildrenConnected"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.PortIndex">
            <summary>
            The index of the port this node is connected to on the parent's <see cref="!:IAnimationMixer.Playable"/>.
            <para></para>
            A negative value indicates that it is not assigned to a port.
            </summary>
            <remarks>
            The setter is internal so user defined states can't set it incorrectly. Ideally,
            <see cref="T:Animancer.AnimancerLayer"/> should be able to set the port in its constructor and
            <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> should also be able to set it, but classes that further inherit from
            there should not be able to change it without properly calling that method.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.#ctor(Animancer.AnimancerPlayable)">
            <summary>Constructs a new <see cref="T:Animancer.AnimancerNode"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ChildCount">
            <summary>The number of states using this node as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetChild(System.Int32)">
            <summary>
            Returns the state connected to the specified 'portIndex' as a child of this node.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnAddChild(Animancer.AnimancerState)">
            <summary>
            Called when a child is connected with this node as its <see cref="P:Animancer.AnimancerState.Parent"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnRemoveChild(Animancer.AnimancerState)">
            <summary>
            Called when a child's <see cref="P:Animancer.AnimancerState.Parent"/> is changed from this node to something else.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnAddChild(System.Collections.Generic.IList{Animancer.AnimancerState},Animancer.AnimancerState)">
            <summary>Connects the 'state' to the 'mixer' at its <see cref="P:Animancer.AnimancerNode.PortIndex"/>.</summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Animancer.AnimancerNode.PortIndex"/> was already occupied.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.ValidateRemoveChild(Animancer.AnimancerState,Animancer.AnimancerState)">
            <summary>[Internal]
            Throws an <see cref="T:System.InvalidOperationException"/> if the provided states are different.
            <para></para>
            Use this method to verify that a state being removed was actually assigned to its specified
            <see cref="P:Animancer.AnimancerNode.PortIndex"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.OnChildDestroyed(Animancer.AnimancerState)">
            <summary>[Internal]
            Called by <see cref="M:Animancer.AnimancerState.Dispose"/> for any states connected to this mixer.
            Adds the 'state's port to a list of spares to be reused by another state and notifies the root
            <see cref="T:Animancer.AnimancerPlayable"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.KeepChildrenConnected">
            <summary>Indicates whether child playables should stay connected to this mixer at all times.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ConnectAllChildrenToGraph">
            <summary>
            Ensures that all children of this node are connected to the <see cref="F:Animancer.AnimancerNode._Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DisconnectWeightlessChildrenFromGraph">
            <summary>
            Ensures that all children of this node which have zero weight are disconnected from the
            <see cref="F:Animancer.AnimancerNode._Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ConnectToGraph">
            <summary>
            Connects the <see cref="F:Animancer.AnimancerNode._Playable"/> to the parent <see cref="!:IAnimationMixer.Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DisconnectFromGraph">
            <summary>
            Disconnects the <see cref="F:Animancer.AnimancerNode._Playable"/> from the parent <see cref="!:IAnimationMixer.Playable"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.IsValid">
            <summary>
            Indicates whether the <see cref="F:Animancer.AnimancerNode._Playable"/> is usable (properly initialised and not destroyed).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetEnumerator">
            <summary>Gets an enumerator for all of this node's child states.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.IsPlayingAndNotEnding">
            <summary>
            Returns true if the animation is playing and hasn't yet reached its end.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.System#Collections#IEnumerator#MoveNext">
            <summary>Calls <see cref="M:Animancer.AnimancerNode.IsPlayingAndNotEnding"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.System#Collections#IEnumerator#Current">
            <summary>Returns null.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.System#Collections#IEnumerator#Reset">
            <summary>Does nothing.</summary>
        </member>
        <member name="F:Animancer.AnimancerNode._Weight">
            <summary>The current blend weight of this layer. Accessed via <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerNode._IsWeightDirty">
            <summary>Indicates whether the weight has changed and should be applied to the parent mixer.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Weight">
            <summary>
            The current blend weight of this node which determines how much it affects the final output.
            0 has no effect while 1 applies the full effect of this node.
            <para></para>
            Setting this property cancels any fade currently in progress. If you don't wish to do that, you can use
            <see cref="M:Animancer.AnimancerNode.SetWeight(System.Single)"/> instead.
            <para></para>
            Animancer Lite only allows this value to be set to 0 or 1 in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.SetWeight(System.Single)">
            <summary>
            Sets the current blend weight of this node which determines how much it affects the final output.
            0 has no effect while 1 applies the full effect of this node.
            <para></para>
            This method allows any fade currently in progress to continue. If you don't wish to do that, you can set
            the <see cref="P:Animancer.AnimancerNode.Weight"/> property instead.
            <para></para>
            Animancer Lite only allows this value to be set to 0 or 1 in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.SetWeightDirty">
            <summary>
            Flags this node as having a dirty weight that needs to be applied next update.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ApplyWeight">
            <summary>[Internal]
            Applies the <see cref="P:Animancer.AnimancerNode.Weight"/> to the connection between this node and its <see cref="P:Animancer.AnimancerNode.Parent"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.TargetWeight">
            <summary>The target blend weight which this layer is fading towards.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.FadeSpeed">
            <summary>The speed at which this layer is fading towards the <see cref="P:Animancer.AnimancerNode.TargetWeight"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerNode.OnStartFade"/> and starts fading the <see cref="P:Animancer.AnimancerNode.Weight"/> over the course
            of the 'fadeDuration' (in seconds).
            <para></para>
            If the 'targetWeight' is 0 then <see cref="M:Animancer.AnimancerNode.Stop"/> will be called when the fade is complete.
            <para></para>
            If the <see cref="P:Animancer.AnimancerNode.Weight"/> is already equal to the 'targetWeight' then the fade will end
            immediately.
            <para></para>
            Animancer Lite only allows a 'targetWeight' of 0 or 1 and the default 'fadeDuration' in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.OnStartFade">
            <summary>
            Called by <see cref="!:FadeExtensions.StartFade"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Stop">
            <summary>
            Stops this node and makes it inactive so it no longer affects the output.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerNode._IsUpdating">
            <summary>
            Indicates whether this has been added to the list of nodes that need to be updated.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.RequireUpdate">
            <summary>
            Adds this to the list of nodes that need to be updated if it wasn't there already.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.UpdateNode(System.Boolean@)">
            <summary>[Internal]
            Calls <see cref="M:Animancer.AnimancerNode.Update(System.Boolean@)"/> and assumes that if 'needsMoreUpdates' returns false then this node will be
            removed from the updating list.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Update(System.Boolean@)">
            <summary>
            Updates the <see cref="P:Animancer.AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays
            or pauses the <see cref="F:Animancer.AnimancerNode._Playable"/> if its state is dirty.
            <para></para>
            If the root <see cref="!:AnimancerPlayable.DisconnectWeightlessPlayables"/> is set to true, this method will
            also connect/disconnect its state from the animation mixer in the playable graph.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.MoveTowards(System.Single,System.Single,System.Single)">
            <summary>
            Moves the 'current' value towards the 'target' without moving more than the 'maxDelta'.
            <para></para>
            This implementation seems to be about twice as fast as <see cref="M:UnityEngine.Mathf.MoveTowards(System.Single,System.Single,System.Single)"/>
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable">
            <summary>
            A <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> which can be used as a substitute for the
            <see cref="T:UnityEngine.RuntimeAnimatorController"/> normally used to control an <see cref="T:UnityEngine.Animator"/>.
            <para></para>
            This class can be used as a custom yield instruction to wait until all animations finish playing.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.DocumentationURL">
            <summary>The URL of the website where the Animancer documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.APIDocumentationURL">
            <summary>The URL of the website where the Animancer API documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.DefaultFadeDuration">
            <summary>
            The fade duration for any of the CrossFade methods to use if the caller doesn't specify.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._Playable">
            <summary>
            The underlying <see cref="T:UnityEngine.Playables.Playable"/> of this <see cref="T:UnityEngine.Playables.PlayableBehaviour"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._Graph">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.CurrentState">
            <summary>
            The state of the animation currently being played on layer 0.
            <para></para>
            Specifically, this is the state that was most recently started using any of the
            <see cref="T:Animancer.AnimancerLayer"/> Play or CrossFade methods on that layer. States controlled individually via
            methods in the <see cref="T:Animancer.AnimancerState"/> itself will not register in this property.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.CurrentStateID">
            <summary>
            The number of times the <see cref="P:Animancer.AnimancerPlayable.CurrentState"/> has changed. By storing this value and later comparing
            the stored value to the current value, you can determine whether the state has been changed since then,
            even if the actual state is the same.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.IsGraphPlaying">
            <summary>Indicates whether the <see cref="!:Graph"/> is currently playing.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._Layers">
            <summary>The layers which each manage their own set of animations.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._RegisteredStates">
            <summary>All of the animation states in any of the root layers (not inside mixers) currently registered to unique keys.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._DirtyEarlyNodes">
            <summary>All of the nodes that need to be updated early.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._DirtyNodes">
            <summary>All of the nodes that need to be updated.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.UpdateMode">
            <summary>Determines what time source is used to update the <see cref="!:Graph"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.ProOnlyMessage">
            <summary>[Lite-Only]
            A message which explains that some features are only available in the Unity Editor for trial purposes in
            Animancer Lite, but not at runtime.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.ValidateLayerIndex(System.Int32@)">
            <summary>[Internal] [Lite-Only]
            Ensures that only layer 0 is used at runtime in the Lite version.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.KeepLoggingProOnlyFeatures">
            <summary>[Lite-Only]
            When a Pro-Only feature is used it will log a message and decrement this value (default 0). Once it becomes
            negative, no more messages will be logged.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LogProOnlyFeature(System.String)">
            <summary>[Internal] [Lite-Only]
            Logs a message the first time a Pro-Only feature is used, then does nothing on subsequent calls.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.KeepPlayablesConnected">
            <summary>
            Indicates whether playables should stay connected to the graph at all times.
            <para></para>
            By default, this value is false so that playables will be disconnected from the graph while they are at 0
            weight which stops it from evaluating them every frame and is generally more efficient.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.Template">
            <summary>
            Since <see cref="M:UnityEngine.Playables.ScriptPlayable`1.Create(UnityEngine.Playables.PlayableGraph,System.Int32)"/> needs to clone an existing instance, we
            keep a static template to avoid allocating an extra garbage one every time.
            This is why the fields are assigned in OnPlayableCreate rather than being readonly with field initialisers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CreatePlayable(System.String)">
            <summary>
            Creates a new <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing an <see cref="T:Animancer.AnimancerPlayable"/>.
            <para></para>
            The caller is responsible for calling <see cref="M:Animancer.AnimancerPlayable.Dispose"/> on the returned object, except in Edit Mode
            where it will be called automatically.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.OnPlayableCreate(UnityEngine.Playables.Playable)">
            <summary>[Internal]
            Called by Unity as it creates an <see cref="T:Animancer.AnimancerPlayable"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.FastComparer">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which ignores overloaded equality operators so it's faster than
            <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> for types derived from <see cref="T:UnityEngine.Object"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.FastComparer.Instance">
            <summary>Singleton instance.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.FastComparer.Equals(System.Object,System.Object)">
            <summary>Calls <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.FastComparer.GetHashCode(System.Object)">
            <summary>Calls <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(UnityEngine.Animator,Animancer.AnimancerPlayable)">
            <summary>
            Plays the 'playable' on the specified 'animator'.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.IsValid">
            <summary>
            Returns true as long as the <see cref="!:Graph"/> hasn't been destroyed (such as by <see cref="M:Animancer.AnimancerPlayable.Dispose"/>).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Dispose">
            <summary>
            Destroys the <see cref="!:Graph"/> and all its layers and states. This operation cannot be undone.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.DestroyStates">
            <summary>
            Destroys all states managed by this playable. This operation cannot be undone.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CreateState(UnityEngine.AnimationClip,System.Int32)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the 'clip' with this
            <see cref="T:Animancer.AnimancerPlayable"/> as its parent.
            <para></para>
            This method does not register the created state with any key, leaving the caller responsible for keeping
            track of it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CreateState(System.Object,UnityEngine.AnimationClip,System.Int32)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the 'clip' and registers it with the 'key'.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.ValidateNode(Animancer.AnimancerNode)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if this is not the <see cref="F:Animancer.AnimancerNode.Root"/>.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.op_Implicit(Animancer.AnimancerPlayable)~Animancer.AnimancerLayer">
            <summary>Returns layer 0.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetState(Animancer.IHasKey)">
            <summary>
            Passes the <see cref="P:Animancer.IHasKey.Key"/> into <see cref="M:Animancer.AnimancerPlayable.GetState(System.Object)"/> and returns the result.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetState(System.Object)">
            <summary>
            Returns the state registered with the 'key', or null if none exists.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.TryGetState(Animancer.IHasKey,Animancer.AnimancerState@)">
            <summary>
            Passes the <see cref="P:Animancer.IHasKey.Key"/> into <see cref="M:Animancer.AnimancerPlayable.TryGetState(System.Object,Animancer.AnimancerState@)"/>
            and returns the result.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.TryGetState(System.Object,Animancer.AnimancerState@)">
            <summary>
            If a state is registered with the 'key', this method outputs it as the 'state' and returns true. Otherwise
            'state' is set to null and this method returns false.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetOrCreateState(Animancer.IAnimancerTransition,System.Int32)">
            <summary>
            Returns the state registered with the 'transition's <see cref="P:Animancer.IHasKey.Key"/> if there is one. Otherwise
            this method uses <see cref="M:Animancer.IAnimancerTransition.CreateState(Animancer.AnimancerLayer)"/> to create a new one and registers it with
            that key before returning it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetOrCreateState(System.Object,UnityEngine.AnimationClip,System.Int32,System.Boolean)">
            <summary>
            Returns the state which registered with the 'key' or creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the 'allowSetClip'
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RegisterState(System.Object,Animancer.AnimancerState)">
            <summary>[Internal]
            Registers the 'state' in the internal dictionary so the 'key' can be used to get it later on using
            <see cref="M:Animancer.AnimancerPlayable.GetState(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.UnregisterState(Animancer.AnimancerState)">
            <summary>[Internal]
            Removes the 'state' from the internal dictionary.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetEnumerator">
            <summary>
            Returns an enumerator that will iterate through all states in each layer (not states inside mixers).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetLayerEnumerator">
            <summary>
            Returns an enumerator that will iterate through all layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetRegisteredStateEnumerator">
            <summary>
            Returns an enumerator for the dictionary containing all currently registered keys and the animation states
            they are mapped to.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.System#Collections#IEnumerator#MoveNext">
            <summary>
            Determines if any animations are still playing so this object can be used as a custom yield instruction.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.System#Collections#IEnumerator#Current">
            <summary>Returns null.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.System#Collections#IEnumerator#Reset">
            <summary>Does nothing.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipSource"/>]
            Gathers all the animations in all layers.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerCount">
            <summary>[Pro-Only]
            The number of animation layers in the graph.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.SetMinLayerCount(System.Int32)">
            <summary>[Pro-Only]
            If the <see cref="P:Animancer.AnimancerPlayable.LayerCount"/> is below the specified 'min', this method increases it to that value.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetLayer(System.Int32)">
            <summary>
            Returns the layer at the specified index. If it didn't already exist, this method creates it.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.maxLayerCount">
            <summary>
            The maximum number of layers that can be created before an <see cref="T:System.ArgumentOutOfRangeException"/> will
            be thrown (default 4).
            <para></para>
            Lowering this value will not affect layers that have already been created.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.AddLayer">
            <summary>[Pro-Only]
            Creates and returns a new <see cref="T:Animancer.AnimancerLayer"/>. New layers will override earlier layers by default.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsLayerAdditive(System.Int32)">
            <summary>[Pro-Only]
            Checks whether the layer at the specified index is set to additive blending. Otherwise it will override any
            earlier layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.SetLayerAdditive(System.Int32,System.Boolean)">
            <summary>[Pro-Only]
            Sets the layer at the specified index to blend additively with earlier layers (if true) or to override them
            (if false). Newly created layers will override by default.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.SetLayerMask(System.Int32,UnityEngine.AvatarMask)">
            <summary>[Pro-Only]
            Sets an <see cref="T:UnityEngine.AvatarMask"/> to determine which bones the layer at the specified index will affect.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.SetLayerName(System.Int32,System.String)">
            <summary>[Editor-Conditional]
            Sets the inspector display name of the layer at the specified index. Note that layer names are Editor-Only
            so any calls to this method will automatically be compiled out of a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)">
            <summary>
            Stops all other animations, plays the 'state', and returns it.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the 'state's time to 0.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(System.Object)">
            <summary>
            Stops all other animations, plays the animation registered with the 'key', and returns that
            state. If no state is registered with the 'key', this method does nothing and returns null.
            <para></para>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the returned state's time to 0.
            on the returned state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CrossFade(Animancer.AnimancerState,System.Single)">
            <summary>
            Starts fading in the 'state' over the course of the 'fadeDuration' while fading out all others in the same
            layer. Returns the 'state'.
            <para></para>
            If the 'state' was already playing, it will continue doing so from the current time, unlike
            <see cref="M:Animancer.AnimancerPlayable.CrossFadeFromStart(Animancer.AnimancerState,System.Single)"/>.
            <para></para>
            If the 'state' was already playing and fading in with less time remaining than the 'fadeDuration', this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="!:Weight"/>, this method will instead start fading in the layer
            itself and simply <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.Animator,Animancer.AnimancerPlayable)"/> the 'state'.
            <para></para>
            Animancer Lite only allows the default 'fadeDuration' (0.3 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CrossFade(System.Object,System.Single)">
            <summary>
            Starts fading in the animation registered with the 'key' over the course of the 'fadeDuration' while fading
            out all others in the same layer. Returns the animation's state (or null if none was registered).
            <para></para>
            If the animation was already playing, it will continue doing so from the current time, unlike
            <see cref="M:Animancer.AnimancerPlayable.CrossFadeFromStart(System.Object,System.Single)"/>.
            <para></para>
            If the animation was already playing and fading in with less time remaining than the 'fadeDuration', this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="!:Weight"/>, this method will instead start fading in the layer
            itself and simply <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.Animator,Animancer.AnimancerPlayable)"/> the 'state'.
            <para></para>
            Animancer Lite only allows the default 'fadeDuration' (0.3 seconds) in a runtime build.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CrossFadeFromStart(Animancer.AnimancerState,System.Single)">
            <summary>
            Starts fading in the 'state' from the start over the course of the 'fadeDuration' while fading out all
            others in the same layer. Returns the 'state'.
            <para></para>
            If the 'state' isn't currently at 0 <see cref="!:AnimancerState.Weight"/>, this method will actually fade it
            to 0 along with the others and create and return a new state with the same clip to fade to 1. This ensures
            that calling this method will always fade out from all current states and fade in from the start of the
            desired animation. States created for this purpose are cached so they can be reused in the future.
            <para></para>
            Calling this method repeatedly on subsequent frames will probably have undesirable effects; you most likely
            want to use <see cref="M:Animancer.AnimancerPlayable.CrossFade(Animancer.AnimancerState,System.Single)"/> instead.
            <para></para>
            If the layer currently has 0 <see cref="!:Weight"/>, this method will instead start fading in the layer
            itself and simply <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.Animator,Animancer.AnimancerPlayable)"/> the 'state'.
            <para></para>
            Animancer Lite only allows the default 'fadeDuration' (0.3 seconds) in a runtime build.
            </summary>
            <remarks>
            This can be useful when you want to repeat an action while the previous animation is still fading out.
            For example, if you play an 'Attack' animation, it ends and starts fading back to 'Idle', and while it is
            doing so you want to start another 'Attack'. The previous 'Attack' can't simply snap back to the start, so
            you can use this method to create a second 'Attack' state to fade in while the old one fades out.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CrossFadeFromStart(System.Object,System.Single)">
            <summary>
            Starts fading in the animation registered with the 'key' from the start over the course of the
            'fadeDuration' while fading out all others in the same layer. Returns its state.
            <para></para>
            If the animation isn't currently at 0 <see cref="!:AnimancerState.Weight"/>, this method will actually fade
            it to 0 along with the others and create and return a new state with the same clip to fade to 1. This
            ensures that calling this method will always fade out from all current states and fade in from the start of
            the desired animation. States created for this purpose are cached so they can be reused in the future.
            <para></para>
            Calling this method repeatedly on subsequent frames will probably have undesirable effects; you most likely
            want to use <see cref="M:Animancer.AnimancerPlayable.CrossFade(System.Object,System.Single)"/> instead.
            <para></para>
            If the layer currently has 0 <see cref="!:Weight"/>, this method will instead start fading in the layer
            itself and simply <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.Animator,Animancer.AnimancerPlayable)"/> the 'state'.
            <para></para>
            Animancer Lite only allows the default 'fadeDuration' (0.3 seconds) in a runtime build.
            </summary>
            <remarks>
            This can be useful when you want to repeat an action while the previous animation is still fading out.
            For example, if you play an 'Attack' animation, it ends and starts fading back to 'Idle', and while it is
            doing so you want to start another 'Attack'. The previous 'Attack' can't simply snap back to the start, so
            you can use this method to create a second 'Attack' state to fade in while the old one fades out.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)">
            <summary>
            Calls either <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)"/>, <see cref="M:Animancer.AnimancerPlayable.CrossFade(Animancer.AnimancerState,System.Single)"/>, or
            <see cref="M:Animancer.AnimancerPlayable.CrossFadeFromStart(Animancer.AnimancerState,System.Single)"/> based on the details of the 'transition'.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(Animancer.IHasKey)">
            <summary>
            Gets the state registered with the <see cref="P:Animancer.IHasKey.Key"/>, stops and rewinds it to the start, then
            returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(System.Object)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Stop"/> on the state registered with the 'key' to stop it from playing and
            rewind it to the start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Stop"/> on all animations to stop them from playing and rewind them to the
            start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(Animancer.IHasKey)">
            <summary>
            Returns true if a state is registered with the <see cref="P:Animancer.IHasKey.Key"/> and it is currently playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(System.Object)">
            <summary>
            Returns true if a state is registered with the 'key' and it is currently playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying">
            <summary>
            Returns true if at least one animation is being played.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlayingClip(UnityEngine.AnimationClip)">
            <summary>
            Returns true if the 'clip' is currently being played by at least one state in any layer.
            <para></para>
            This method is inefficient because it searches through every state to find any that are playing the 'clip',
            unlike <see cref="!:IsPlaying(AnimationClip)"/> which only checks the state registered using the 'clip's key.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlayingClip(UnityEngine.AnimationClip,System.Int32)">
            <summary>
            Returns true if the 'clip' is currently being played by at least one state in the specified layer.
            <para></para>
            This method is inefficient because it searches through every state to find any that are playing the 'clip',
            unlike <see cref="!:IsPlaying(AnimationClip)"/> which only checks the state registered using the 'clip's key.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.UnpauseGraph">
            <summary>
            Resumes playing the <see cref="!:Graph"/> if <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/> was called previously.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PauseGraph">
            <summary>
            Freezes the <see cref="!:Graph"/> at its current state.
            <para></para>
            If you call this method, you are responsible for calling <see cref="M:Animancer.AnimancerPlayable.UnpauseGraph"/> to resume playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Evaluate">
            <summary>
            Evaluates all of the currently playing animations to apply their states to the animated objects.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Evaluate(System.Single)">
            <summary>
            Advances all currently playing animations by the specified amount of time (in seconds) and evaluates the
            graph to apply their states to the animated objects.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetTotalWeight">
            <summary>
            Calculates the total <see cref="!:AnimancerState.Weight"/> of all states in this playable.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.AverageVelocity">
            <summary>
            The average velocity of the root motion of all currently playing animations, taking their current
            <see cref="!:AnimancerState.Weight"/> into account.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.OnEndEventReceived(UnityEngine.AnimationEvent)">
            <summary>
            Invokes the <see cref="P:Animancer.AnimancerState.OnEnd"/> event of the state that is playing the animation which
            triggered the event. Returns true if such a state exists (even if it doesn't have a callback registered).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.TryInvokeOnEndEvent(UnityEngine.AnimationEvent,Animancer.AnimancerState)">
            <summary>
            If the <see cref="P:Animancer.AnimancerState.Clip"/> and <see cref="P:Animancer.AnimancerNode.Weight"/> match the
            <see cref="T:UnityEngine.AnimationEvent"/>, this method invokes the <see cref="P:Animancer.AnimancerState.OnEnd"/> event and returns
            true.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.CurrentEndEvent">
            <summary>
            The <see cref="T:UnityEngine.AnimationEvent"/> called 'End' which is currently being triggered.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.CurrentlyEnding">
            <summary>
            The <see cref="T:Animancer.AnimancerState"/> which is currently having its <see cref="P:Animancer.AnimancerState.OnEnd"/> event
            triggered by an <see cref="T:UnityEngine.AnimationEvent"/> called 'End'.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetFadeOutDuration(System.Single)">
            <summary>
            If the <see cref="P:Animancer.AnimancerPlayable.CurrentEndEvent"/> has a float parameter above 0, this method returns that value.
            Otherwise it returns either the 'minDuration' or the <see cref="P:Animancer.AnimancerState.RemainingDuration"/> of the
            <see cref="P:Animancer.AnimancerPlayable.CurrentlyEnding"/> state (whichever is higher).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RequireEarlyUpdate``1(``0)">
            <summary>
            Adds the 'node' to the list of nodes that need to be updated.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RequireUpdate(Animancer.AnimancerNode)">
            <summary>
            Adds the 'node' to the list of nodes that need to be updated early.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.DeltaTime">
            <summary>
            The current <see cref="P:UnityEngine.Playables.FrameData.deltaTime"/>.
            <para></para>
            After <see cref="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>, this property will be left at its most recent value.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.FrameID">
            <summary>
            The current <see cref="P:UnityEngine.Playables.FrameData.frameId"/>.
            <para></para>
            <see cref="T:Animancer.ClipState"/> uses this value to determine whether it has accessed the playable's time since it
            was last updated in order to cache the <see cref="P:Animancer.ClipState.Time"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
            <summary>[Internal]
            Called by Unity before the <see cref="!:Graph"/> is evaluated. Updates the playing states.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerState">
            <summary>
            Base class for all states in an <see cref="T:Animancer.AnimancerPlayable"/> graph.
            Each state is a wrapper for a <see cref="T:UnityEngine.Playables.Playable"/> in the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            <para></para>
            This class can be used as a custom yield instruction to wait until the animation either stops playing or reaches its end.
            </summary>
            <remarks>
            There are various different ways of getting a state:
            <list type="bullet">
              <item>
              Use one of the state's constructors. Generally the first parameter is a layer or mixer which will be used as
              the state's parent. If not specified, you will need to call SetParent manually. Also note than an
              AnimancerComponent can be implicitly cast to its first layer.
              </item>
              <item>
              AnimancerController.CreateState creates a new ClipState. You can optionally specify a custom 'key' to
              register it in the dictionary instead of the default (the 'clip' itself).
              </item>
              <item>
              AnimancerController.GetOrCreateState looks for an existing state registered with the specified 'key' and only
              creates a new one if it doesn’t already exist.
              </item>
              <item>
              AnimancerController.GetState returns an existing state registered with the specified 'key' if there is one.
              </item>
              <item>
              AnimancerController.TryGetState is similar but returns a bool to indicate success and returns the 'state'
              as an out parameter.
              </item>
              <item>
              AnimancerController.Play and CrossFade also return the state they play.
              </item>
            </list>
            <para></para>
            Note that when inheriting from this class, the <see cref="!:_Playable"/> field must be assigned in the
            constructor to avoid throwing <see cref="T:System.ArgumentException"/>s throughout the system.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.Parent">
            <summary>
            The node which receives the output of this node.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Connects this state to the 'parent' mixer at the specified 'portIndex'.
            <para></para>
            See also <see cref="M:Animancer.AnimancerLayer.AddChild(Animancer.AnimancerState)"/> to connect a state to an available port on a
            layer.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.ParentPlayable">
            <summary>The parent's <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.StayConnectedWhenWeightless">
            <summary>The <see cref="P:Animancer.AnimancerState.Parent"/>'s <see cref="P:Animancer.AnimancerNode.KeepChildrenConnected"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.EffectiveWeight">
            <summary>
            The <see cref="P:Animancer.AnimancerNode.Weight"/> of this state multiplied by the <see cref="P:Animancer.AnimancerNode.Weight"/> of each of
            its parents down the hierarchy to determine how much this state affects the final output.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Layer">
            <summary>The root <see cref="T:Animancer.AnimancerLayer"/> which this state is connected to.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.LayerIndex">
            <summary>
            The index of the <see cref="T:Animancer.AnimancerLayer"/> this state is connected to (determined by the
            <see cref="P:Animancer.AnimancerState.Parent"/>).
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays (if any).</summary>
            <exception cref="T:System.NotSupportedException">
            Thrown if this state type doesn't have a clip and you try to set it.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerState.MainObject">
            <summary>The main object to show in the Inspector for this state (if any).</summary>
            <exception cref="T:System.NotSupportedException">
            Thrown if this state type doesn't have a main object and you try to set it.
            </exception>
            <exception cref="T:System.InvalidCastException">
            Thrown if you try to assign something this state can't use.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.Key">
            <summary>
            The object used to identify this state in the root <see cref="T:Animancer.AnimancerPlayable"/> dictionary.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState._IsPlaying">
            <summary>Is the <see cref="P:Animancer.AnimancerState.Time"/> automatically advancing?</summary>
        </member>
        <member name="F:Animancer.AnimancerState._IsPlayingDirty">
            <summary>
            Has <see cref="F:Animancer.AnimancerState._IsPlaying"/> changed since it was last applied to the <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
            <remarks>
            Playables start playing by default so we start dirty to pause it during the first update (unless
            <see cref="P:Animancer.AnimancerState.IsPlaying"/> is set to true before that).
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.IsPlaying">
            <summary>Is the <see cref="P:Animancer.AnimancerState.Time"/> automatically advancing?</summary>
            
            <example>
            <code>
            void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip)
            {
                var state = animancer.GetOrCreateState(clip);
                
                if (state.IsPlaying)
                    Debug.Log(clip + " is playing");
                else
                    Debug.Log(clip + " is paused");
                    
                state.IsPlaying = false;// Pause the animation.
                    
                state.IsPlaying = true;// Unpause the animation.
            }
            </code>
            </example>
        </member>
        <member name="P:Animancer.AnimancerState.IsActive">
            <summary>
            Returns true if this state is playing and is at or fading towards a non-zero
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.IsStopped">
            <summary>
            Returns true if this state is not playing and is at 0 <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Time">
            <summary>
            The number of seconds that have passed since the start of this animation.
            <para></para>
            This value will continue increasing after the animation passes the end of its <see cref="P:Animancer.AnimancerState.Length"/> and it
            will either freeze in place or start again from the beginning according to whether it is looping or not.
            <para></para>
            Animancer Lite does not allow this value to be changed in a runtime build (except setting it to 0).
            </summary>
            <remarks>
            Setting this value actually calls <see cref="M:UnityEngine.Playables.PlayableExtensions.SetTime``1(``0,System.Double)"/> twice to ensure that animation
            events aren't triggered incorrectly. Calling it only once would trigger any animation events between the
            previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as
            by calling <see cref="M:Animancer.AnimancerState.Stop"/> or playing a different animation), the next time this animation played it
            would immediately trigger all of its events, then play through and trigger them normally as well.
            </remarks>
            
            <example>
            <code>
            void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
            {
                var state = animancer.Play(clip);
                
                // Start 0.5 seconds into the animation:
                state.Time = 0.5f;
                
                // Start 50% of the way through the animation (0.5 in a range of 0 to 1):
                state.NormalizedTime = 0.5f;
            }
            </code>
            </example>
        </member>
        <member name="P:Animancer.AnimancerState.NormalizedTime">
            <summary>
            The <see cref="P:Animancer.AnimancerState.Time"/> of this state as a portion of the animation's <see cref="P:Animancer.AnimancerState.Length"/>, meaning the
            value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes.
            <para></para>
            This value will continue increasing after the animation passes the end of its length and it will either
            freeze in place or start again from the beginning according to whether it is looping or not.
            <para></para>
            The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the
            current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has
            been looped.
            <para></para>
            Animancer Lite does not allow this value to be changed to a value other than 0 in a runtime build.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't have a length, as indicated by
            <see cref="P:Animancer.AnimancerState.HasLength"/>.</exception>
            
            <example>
            <code>
            void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
            {
                var state = animancer.Play(clip);
                
                // Start 0.5 seconds into the animation:
                state.Time = 0.5f;
                
                // Start 50% of the way through the animation (0.5 in a range of 0 to 1):
                state.NormalizedTime = 0.5f;
            }
            </code>
            </example>
        </member>
        <member name="P:Animancer.AnimancerState.Speed">
            <summary>
            How fast the <see cref="P:Animancer.AnimancerState.Time"/> is advancing every frame.
            <para></para>
            1 is the normal speed.
            <para></para>
            A negative value will play the animation backwards.
            <para></para>
            Animancer Lite does not allow this value to be changed in a runtime build.
            </summary>
            
            <example>
            <code>
            void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
            {
                var state = animancer.Play(clip);
                
                state.Speed = 1;// Normal speed.
                state.Speed = 2;// Double speed.
                state.Speed = 0.5f;// Half speed.
                state.Speed = -1;// Normal speed playing backwards.
            }
            </code>
            </example>
        </member>
        <member name="P:Animancer.AnimancerState.NormalizedSpeed">
            <summary>
            The number of times per second that the animation will play its complete <see cref="P:Animancer.AnimancerState.Length"/>.
            <para></para>
            A negative value will play the animation backwards.
            <para></para>
            Animancer Lite does not allow this value to be changed in a runtime build.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't have a length, as indicated by
            <see cref="P:Animancer.AnimancerState.HasLength"/>.</exception>
            
            <example>
            <code>
            void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
            {
                var state = animancer.Play(clip);
                
                state.NormalizedSpeed = 1;// Play fully in 1 second.
                state.NormalizedSpeed = 2;// Play through twice per second.
                state.NormalizedSpeed = 0.5f;// Play half the animation per second.
                state.NormalizedSpeed = -1;// Play backwards fully in 1 second.
            }
            </code>
            </example>
        </member>
        <member name="P:Animancer.AnimancerState.Duration">
            <summary>
            The number of seconds the animation will take to play fully at its current <see cref="P:Animancer.AnimancerState.Speed"/>.
            <para></para>
            Setting this value modifies the <see cref="P:Animancer.AnimancerState.Speed"/>, not the <see cref="P:Animancer.AnimancerState.Length"/>.
            Animancer Lite does not allow this value to be changed in a runtime build.
            <para></para>
            For the time remaining from now until it reaches the end, use <see cref="P:Animancer.AnimancerState.RemainingDuration"/> instead.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't have a length, as indicated by
            <see cref="P:Animancer.AnimancerState.HasLength"/>.</exception>
            
            <example>
            <code>
            void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
            {
                var state = animancer.Play(clip);
                
                state.Duration = 1;// Play fully in 1 second.
                state.Duration = 2;// Play fully in 2 seconds.
                state.Duration = 0.5f;// Play fully in half a second.
                state.Duration = -1;// Play backwards fully in 1 second.
            }
            </code>
            </example>
        </member>
        <member name="P:Animancer.AnimancerState.RemainingDuration">
            <summary>
            The number of seconds the animation will take to reach the end at its current <see cref="P:Animancer.AnimancerState.Speed"/>.
            <para></para>
            Setting this value modifies the <see cref="P:Animancer.AnimancerState.Speed"/>, not the <see cref="P:Animancer.AnimancerState.Length"/>.
            Animancer Lite does not allow this value to be changed in a runtime build.
            <para></para>
            For the time it would take to play fully from the start, use <see cref="P:Animancer.AnimancerState.Duration"/> instead.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't have a length, as indicated by
            <see cref="P:Animancer.AnimancerState.HasLength"/>.</exception>
            
            <example>
            <code>
            void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
            {
                var state = animancer.Play(clip);
                
                state.RemainingDuration = 1;// Play from the current time to the end in 1 second.
                state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds.
                state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second.
                state.RemainingDuration = -1;// Play backwards from the current time to the end in 1 second.
            }
            </code>
            </example>
        </member>
        <member name="P:Animancer.AnimancerState.Length">
            <summary>
            The total time this state takes to play in seconds (when <c>Speed = 1</c>).
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't have a length, as indicated by
            <see cref="P:Animancer.AnimancerState.HasLength"/>.</exception>
        </member>
        <member name="P:Animancer.AnimancerState.HasLength">
            <summary>
            Does this state have a valid <see cref="P:Animancer.AnimancerState.Length"/> value?
            <para></para>
            For example, a state that plays an <see cref="T:UnityEngine.AnimationClip"/> will be able to use its
            <see cref="P:UnityEngine.AnimationClip.length"/>, however a state that mixes several other states will not have a length
            of its own.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.IsLooping">
            <summary>
            Indicates whether this state will loop back to the start when it reaches the end.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.OnEnd">
            <summary>
            A callback which is triggered when the animation reaches its end (not when the state is exited for
            whatever reason).
            <para></para>
            If the animation is looping, this callback will be triggered every time it passes the end. Otherwise it
            will be triggered every frame while it is past the end so if you want to ensure that your callback only
            occurs once, you will need to clear it as part of that callback.
            <para></para>
            This callback is automatically cleared by <see cref="M:Animancer.AnimancerState.Play"/>, <see cref="M:Animancer.AnimancerState.OnStartFade"/>, and
            <see cref="M:Animancer.AnimancerState.Stop"/>.
            </summary>
            
            <example>
            <code>
            void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
            {
                Debug.Log("Playing " + clip.name);
                var state = animancer.Play(clip);
                
                // Lambda expression:
                state.OnEnd = () =>
                {
                    Debug.Log(clip.name + " ended");
                };
                
                // One-line Lambda expression:
                state.OnEnd = () => Debug.Log(clip.name + " ended");
                
                // Anonymous method (functionally identical to the Lambda expression):
                state.OnEnd = delegate()
                {
                    Debug.Log(clip.name + " ended");
                };
                
                // Regular Method:
                state.OnEnd = OnAnimationEnd;
            }
            
            void OnAnimationEnd()
            {
                Debug.Log("Animation ended");
            }
            </code>
            <h2>Caching Delegates</h2>
            The above examples will all allocate some garbage every time they are used which can cause performance
            issues. This can be avoided by caching the delegate:
            <para></para><code>
            private System.Action _OnAnimationEnd;
            
            void Awake()
            {
                _OnAnimationEnd = () => Debug.Log("Animation ended");
            }
            
            void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
            {
                animancer.Play(clip).OnEnd = _OnAnimationEnd;
            }
            </code>
            <h2>Serializables</h2>
            You can also use the <see cref="P:Animancer.ClipState.Serializable.OnEnd"/> callback which does not get cleared, so you
            can assign the delegate once on startup and it will use that for the state every time it is played:
            <para></para><code>
            [SerializeField]
            private ClipState.Serializable _Animation;
            
            void Awake()
            {
                _Animation.OnEnd = () => Debug.Log("Animation ended");
            }
            
            void PlayAnimation(AnimancerComponent animancer)
            {
                animancer.Transition(_Animation);
            }
            </code>
            Note that we aren't passing an <see cref="T:UnityEngine.AnimationClip"/> into <c>PlayAnimation</c> like the previous examples. Usually you would
            already have a serialized field for the <see cref="T:UnityEngine.AnimationClip"/> so you would simply replace it with a
            <see cref="T:Animancer.ClipState.Serializable"/>.
            </example>
            
            <remarks>
            The reason for this callback being automatically cleared all the time is so that you don't have to worry
            about other scripts that might have used the same animation previously.
            <para></para>
            For example, if a character has an <em>Attack</em> animation which wants to return to <em>Idle</em> when it
            finishes but the character gets hit by an enemy in the middle of the <em>Attack</em>, the character will
            now want to play the <em>Flinch</em> animation and return to <em>Idle</em> after that instead. At that
            point, we no longer care about the end of the <em>Attack</em> animation.
            <para></para>
            If we want to attack again, we just play the animation and register the callback again. But if the
            character has a special skill that lets them perform an attack combo which includes the same
            <em>Attack</em> animation followed by several others in sequence, that skill won't want it to still have
            the <see cref="P:Animancer.AnimancerState.OnEnd"/> callback that returns to idle.
            <para></para>
            This way, each script that plays an animation takes over the responsibility for managing what it expects to
            happen without worrying about the expectations of other scripts.
            <para></para>
            That said, enforcing rules for which animations/actions are allowed to interrupt each other is often very
            important so it is covered in the
            <see href="https://kybernetikgames.github.io/animancer/docs/examples/state-machines/interrupt-management">
            State Machines/Interrupt Management</see> example.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.ApplyAnimatorIK">
            <summary>
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK"/>.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while a state was at
            <see cref="P:Animancer.AnimancerNode.Weight"/> == 1 which meant that IK would not work while fading between animations.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.ApplyFootIK">
            <summary>
            Indicates whether this state is applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyFootIK"/>.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>Constructs a new <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Play">
            <summary>
            Plays this animation immediately, without any blending.
            Sets <see cref="P:Animancer.AnimancerState.IsPlaying"/> = true, <see cref="!:Weight"/> = 1, and <see cref="P:Animancer.AnimancerState.OnEnd"/> = null.
            <para></para>
            This method does not change the <see cref="P:Animancer.AnimancerState.Time"/> so it will continue from its current value.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Stop">
            <summary>
            Stops the animation and makes it inactive immediately so it no longer affects the output.
            Sets <see cref="P:Animancer.AnimancerState.IsPlaying"/> = false, <see cref="P:Animancer.AnimancerState.Time"/> = 0, <see cref="!:Weight"/> = 0, and
            <see cref="P:Animancer.AnimancerState.OnEnd"/> = null.
            <para></para>
            If you only want to freeze the animation in place, you can set <see cref="P:Animancer.AnimancerState.IsPlaying"/> = false instead.
            Or to freeze all animations, you can call <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.OnStartFade">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/>. Clears the <see cref="P:Animancer.AnimancerState.OnEnd"/> event.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Dispose">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.HasEvent(System.String)">
            <summary>Checks if this state has an animation event with the specified 'functionName'.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipSource"/>]
            Gathers all the animations associated with this state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.GetDescription(System.Boolean,System.Boolean,System.String)">
            <summary>Returns a detailed descrption of the current details of this state.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendDescription(System.Text.StringBuilder,System.Boolean,System.Boolean,System.String)">
            <summary>Appends a detailed descrption of the current details of this state.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.GetPath">
            <summary>Returns the hierarchy path of this state through its <see cref="P:Animancer.AnimancerState.Parent"/>s.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendPath(System.Text.StringBuilder,Animancer.AnimancerNode)">
            <summary>Appends the hierarchy path of this state through its <see cref="P:Animancer.AnimancerState.Parent"/>s.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendPortAndType(System.Text.StringBuilder)">
            <summary>Appends "[PortIndex] -> GetType().Name".</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Update(System.Boolean@)">
            <summary>[Internal]
            Updates the <see cref="!:Weight"/> for fading, applies it to this state's port on the parent mixer, and plays
            or pauses the <see cref="T:UnityEngine.Playables.Playable"/> if its state is dirty.
            <para></para>
            If the root <see cref="!:AnimancerPlayable.DisconnectWeightlessPlayables"/> is set to true, this method will
            also connect/disconnect its state from the animation mixer in the playable graph.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.IsPlayingAndNotEnding">
            <summary>
            Returns true if the animation is playing and hasn't yet reached its end.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't have a length, as indicated by
            <see cref="P:Animancer.AnimancerState.HasLength"/>.</exception>
        </member>
        <member name="T:Animancer.AnimancerState.Serializable`1">
            <summary>
            Base class for serializable objects which can create a particular type of <see cref="T:Animancer.AnimancerState"/> when
            passed into <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
            <remarks>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.Serializable`1.FadeDuration">
            <summary>The amount of time the transition should take (in seconds).</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception>
        </member>
        <member name="P:Animancer.AnimancerState.Serializable`1.State">
            <summary>
            The state that was most recently created by this object.
            </summary>
            <remarks>
            Often a <see cref="T:Animancer.AnimancerState.Serializable`1"/> will only be used on a single object so it will only ever
            create one state, however it is possible to use them on multiple different objects, in which case it
            will create a new state for each object. Each state must be retrieved by using the <see cref="P:Animancer.AnimancerState.Serializable`1.Key"/> in
            <see cref="M:Animancer.AnimancerPlayable.GetState(System.Object)"/> since this property will only hold the last one.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.Serializable`1.Key">
            <summary>
            The <see cref="P:Animancer.AnimancerState.Key"/> which the created state will be registered with.
            <para></para>
            By default, a serializable is used as its own <see cref="P:Animancer.AnimancerState.Serializable`1.Key"/>, but this property can be overridden.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Serializable`1.CrossFadeFromStart">
            <summary>
            When a serializable is passed into <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>, this property
            determines whether it needs to fade in from the start of the animation.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Serializable`1.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <typeparamref name="TState"/> connected to the 'layer'.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/> (which must be done manually when overriding
            this method).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Serializable`1.Animancer#IAnimancerTransition#CreateState(Animancer.AnimancerLayer)">
            <summary>Creates and returns a new <typeparamref name="TState"/> connected to the 'layer'.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Serializable`1.Apply(Animancer.AnimancerState)">
            <summary>[<see cref="T:Animancer.IAnimancerTransition"/>]
            Called by <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/> to apply any modifications to the 'state'.
            </summary>
        </member>
        <member name="T:Animancer.ClipState">
            <summary>
            An <see cref="T:Animancer.AnimancerState"/> which plays an <see cref="T:UnityEngine.AnimationClip"/>.
            </summary>
        </member>
        <member name="F:Animancer.ClipState._Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.MainObject">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="F:Animancer.ClipState._Time">
            <summary>
            The current time of the <see cref="T:UnityEngine.Playables.Playable"/>, retrieved by <see cref="P:Animancer.ClipState.Time"/> whenever
            <see cref="!:_IsTimeDirty"/> is false.</summary>
        </member>
        <member name="F:Animancer.ClipState._TimeFrameID">
            <summary>
            The <see cref="P:Animancer.AnimancerPlayable.FrameID"/> from when the <see cref="P:Animancer.ClipState.Time"/> was last retrieved from the
            <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="F:Animancer.ClipState._EstimatedLoopCount">
            <summary>
            The estimated number of times the animation would have looped this frame which was calculated last frame.
            Only used for checking <see cref="P:Animancer.ClipState.OnEnd"/> events on looping animations.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Time">
            <summary>
            The number of seconds that have passed since the start of this animation.
            <para></para>
            This value will continue increasing after the animation passes the end of its <see cref="P:Animancer.ClipState.Length"/> and it
            will either freeze in place or start again from the beginning according to whether it is looping or not.
            <para></para>
            Animancer Lite does not allow this value to be changed in a runtime build (except setting it to 0).
            </summary>
            <remarks>
            See <see cref="P:Animancer.AnimancerState.Time"/> for more details.
            </remarks>
        </member>
        <member name="P:Animancer.ClipState.Length">
            <summary>
            The <see cref="P:UnityEngine.AnimationClip.length"/>.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.HasLength">
            <summary>
            Indicates whether this state will return a valid <see cref="P:Animancer.ClipState.Length"/> value.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.IsLooping">
            <summary>
            Indicates whether this state will loop back to the start when it reaches the end.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.OnEnd">
            <summary>
            A callback which is triggered when the animation reaches its end (not when the state is exited for
            whatever reason).
            <para></para>
            If the animation is looping, this callback will be triggered every time it passes the end. Otherwise it
            will be triggered every frame while it is past the end so if you want to ensure that your callback only
            occurs once, you will need to clear it as part of that callback.
            <para></para>
            This callback is automatically cleared by <see cref="!:Play"/>, <see cref="!:OnStartFade"/>, and
            <see cref="!:Stop"/>.
            </summary>
            <remarks>
            <see cref="P:Animancer.AnimancerState.OnEnd"/> for more details. Hopefully a future version of C# will implement the
            ability for documentation to be inherited so these comments don't need to be duplicated all the time.
            </remarks>
        </member>
        <member name="P:Animancer.ClipState.ApplyAnimatorIK">
            <summary>
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK"/>.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while a state was at
            <see cref="P:Animancer.AnimancerNode.Weight"/> == 1 which meant that IK would not work while fading between animations.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.ApplyFootIK">
            <summary>
            Indicates whether this state is applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyFootIK"/>.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.InitialiseIKDefaults(Animancer.AnimancerLayer)">
            <summary>
            Applies the default IK flags from the specified 'layer'.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.#ctor(Animancer.AnimancerPlayable,UnityEngine.AnimationClip)">
            <summary>
            Constructs a new <see cref="T:Animancer.ClipState"/> to play the 'clip' without connecting it to the
            <see cref="T:UnityEngine.Playables.PlayableGraph"/>. You must call <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> or it
            won't actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.#ctor(Animancer.AnimancerLayer,UnityEngine.AnimationClip)">
            <summary>
            Constructs a new <see cref="T:Animancer.ClipState"/> to play the 'clip' and connects it to a new port on the 'layer's
            <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.AnimationClip)">
            <summary>
            Constructs a new <see cref="T:Animancer.ClipState"/> to play the 'clip' and connects it to the 'parent's
            <see cref="T:UnityEngine.Playables.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.ValidateClip(UnityEngine.AnimationClip)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if the 'clip' is marked as <see cref="P:UnityEngine.AnimationClip.legacy"/>.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="F:Animancer.ClipState._IsEarlyUpdating">
            <summary>
            Indicates whether this has been added to the list of nodes that need to be updated early.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.RequireEarlyUpdate">
            <summary>
            Adds this to the list of nodes that need to be updated early if it wasn't there already.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Animancer#IEarlyUpdate#EarlyUpdate(System.Boolean@)">
            <summary>[Internal]
            Checks if the animation has reached its end in order to trigger the <see cref="P:Animancer.ClipState.OnEnd"/> event.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.HasEvent(System.String)">
            <summary>Checks if the <see cref="P:Animancer.ClipState.Clip"/> has an animation event with the specified 'functionName'.</summary>
        </member>
        <member name="M:Animancer.ClipState.HasEvent(UnityEngine.AnimationClip,System.String)">
            <summary>Checks if the 'clip' has an animation event with the specified 'functionName'.</summary>
        </member>
        <member name="M:Animancer.ClipState.ToString">
            <summary>
            Returns a string describing the type of this state and the name of the <see cref="P:Animancer.ClipState.Clip"/>.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.AppendDescription(System.Text.StringBuilder,System.Boolean,System.Boolean,System.String)">
            <summary>Appends a detailed descrption of the current details of this state.</summary>
        </member>
        <member name="M:Animancer.ClipState.AppendDelegate(System.Text.StringBuilder,System.Delegate,System.String,System.String)">
            <summary>Appends the <see cref="P:System.Delegate.Target"/> and <see cref="P:System.Delegate.Method"/> of 'del'.</summary>
        </member>
        <member name="M:Animancer.ClipState.Dispose">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="T:Animancer.ClipState.Serializable">
            <summary>
            A serializable object which can create a <see cref="T:Animancer.ClipState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Serializable.Clip">
            <summary>The animation to play.</summary>
        </member>
        <member name="P:Animancer.ClipState.Serializable.Key">
            <summary>
            The <see cref="P:Animancer.ClipState.Serializable.Clip"/> will be used as the <see cref="P:Animancer.AnimancerState.Key"/> for the created state to be
            registered with.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Serializable.Speed">
            <summary>Determines how fast the animation plays (default = 1).</summary>
        </member>
        <member name="P:Animancer.ClipState.Serializable.StartTime">
            <summary>
            Determines what time to start the animation at (either the raw <see cref="P:Animancer.AnimancerState.Time"/> or
            the <see cref="P:Animancer.AnimancerState.NormalizedTime"/> based on <see cref="P:Animancer.ClipState.Serializable.StartTimeIsNormalized"/>).
            <para></para>
            The default value is <see cref="F:System.Single.NaN"/> which indicates that this value isn't used so the
            animation will continue from its current time.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Serializable.CrossFadeFromStart">
            <summary>
            If this transition will set the <see cref="P:Animancer.ClipState.Serializable.StartTime"/>, then it needs to use
            <see cref="M:Animancer.AnimancerPlayable.CrossFadeFromStart(Animancer.AnimancerState,System.Single)"/>.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Serializable.StartTimeIsNormalized">
            <summary>
            Determines whether the <see cref="P:Animancer.ClipState.Serializable.StartTime"/> sets the <see cref="P:Animancer.AnimancerState.Time"/> or
            <see cref="P:Animancer.AnimancerState.NormalizedTime"/>.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.Serializable.OnEnd">
            <summary>
            A callback which is triggered when the animation reaches its end (not when the state is exited for
            whatever reason).
            <para></para>
            If the animation is looping, this callback will be triggered every time it passes the end. Otherwise it
            will be triggered every frame while it is past the end so if you want to ensure that your callback only
            occurs once, you will need to clear it as part of that callback.
            <para></para>
            See <see cref="P:Animancer.AnimancerState.OnEnd"/> for more details.
            </summary>
            <remarks>
            This property is not serialized, but <see cref="T:Animancer.ClipState.SerializableWithEndEvent"/> adds a
            <see cref="T:UnityEngine.Events.UnityEvent"/> that is serialized and can be edited in the Inspector.
            </remarks>
        </member>
        <member name="M:Animancer.ClipState.Serializable.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> connected to the 'layer'.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/>.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.Serializable.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/> to apply the <see cref="P:Animancer.ClipState.Serializable.Speed"/> and
            <see cref="P:Animancer.ClipState.Serializable.StartTime"/>.
            </summary>
        </member>
        <member name="T:Animancer.ClipState.SerializableWithEndEvent">
            <summary>
            A serializable object which can create a <see cref="T:Animancer.ClipState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>. It also has a <see cref="T:UnityEngine.Events.UnityEvent"/> which is triggered
            by the <see cref="P:Animancer.AnimancerState.OnEnd"/> callback.
            </summary>
        </member>
        <member name="P:Animancer.ClipState.SerializableWithEndEvent.OnEnd">
            <summary>
            A callback which is triggered when the animation reaches its end (not when the state is exited for
            whatever reason).
            <para></para>
            If the animation is looping, this callback will be triggered every time it passes the end. Otherwise it
            will be triggered every frame while it is past the end so if you want to ensure that your callback only
            occurs once, you will need to clear it as part of that callback.
            <para></para>
            See <see cref="P:Animancer.AnimancerState.OnEnd"/> for more details.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.SerializableWithEndEvent.OnBeforeSerialize">
            <summary>[<see cref="T:UnityEngine.ISerializationCallbackReceiver"/>]
            Called in the Unity Editor before this object is serialized. Does nothing unless overridden.
            </summary>
        </member>
        <member name="M:Animancer.ClipState.SerializableWithEndEvent.OnAfterDeserialize">
            <summary>[<see cref="T:UnityEngine.ISerializationCallbackReceiver"/>]
            Called after this object is deserialized to ensure that the <see cref="M:UnityEngine.Events.UnityEvent.Invoke"/> method is
            assigned to the <see cref="P:Animancer.ClipState.Serializable.OnEnd"/> callback.
            </summary>
        </member>
        <member name="T:Animancer.ControllerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which plays a <see cref="T:UnityEngine.RuntimeAnimatorController"/>.
            You can control this state very similarly to an <see cref="T:UnityEngine.Animator"/> via its <see cref="P:Animancer.ControllerState.Playable"/> field.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Controller">
            <summary>The <see cref="T:UnityEngine.RuntimeAnimatorController"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ControllerState.MainObject">
            <summary>The <see cref="T:UnityEngine.RuntimeAnimatorController"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ControllerState.Playable">
            <summary>The internal system which plays the <see cref="T:UnityEngine.RuntimeAnimatorController"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.OnEnd">
            <summary>
            <see cref="T:Animancer.ControllerState"/>s don't track the progress of a single animation so this event isn't
            used and will be ignored.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.#ctor(Animancer.AnimancerPlayable,UnityEngine.RuntimeAnimatorController)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState"/> to play the 'animatorController' without connecting
            it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>. You must call <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> or it won't
            actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.#ctor(Animancer.AnimancerLayer,UnityEngine.RuntimeAnimatorController)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState"/> to play the 'animatorController' and connects it to
            the 'layer's <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from previously
            destroyed states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.RuntimeAnimatorController)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState"/> to play the 'animatorController' and connects it to
            the 'parent's <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.HasEvent(System.String)">
            <summary>Checks if any clip in the <see cref="P:Animancer.ControllerState.Controller"/> has an animation event with the specified 'functionName'.</summary>
        </member>
        <member name="P:Animancer.ControllerState.Length">
            <summary>
            The current <see cref="P:UnityEngine.AnimatorStateInfo.length"/>.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.HasLength">
            <summary>
            Indicates whether this state will return a valid <see cref="P:Animancer.ControllerState.Length"/> value.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.IsLooping">
            <summary>
            Indicates whether the current state will loop back to the start when it reaches the end.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.AverageVelocity">
            <summary>[Unsupported]
            Returns <see cref="P:UnityEngine.Vector3.zero"/> since <see cref="T:UnityEngine.Animations.AnimatorControllerPlayable"/> doesn't expose the
            average velocity.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.ToString">
            <summary>
            Returns a string describing the type of this state and the name of the <see cref="P:Animancer.ControllerState.Controller"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipSource"/>]
            Gathers all the animations associated with this state.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Dispose">
            <summary>Destroys the <see cref="P:Animancer.ControllerState.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.ApplyFootIK">
            <summary>
            Does nothing and returns false since <see cref="T:UnityEngine.Animations.AnimatorControllerPlayable"/> doesn't expose this function.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.ApplyAnimatorIK">
            <summary>
            Does nothing and returns false since <see cref="T:UnityEngine.Animations.AnimatorControllerPlayable"/> doesn't expose this function.
            </summary>
        </member>
        <member name="T:Animancer.ControllerState.Parameter">
            <summary>
            A wrapper for the name and hash of an <see cref="T:UnityEngine.AnimatorControllerParameter"/> to allow easy access.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Parameter.Name">
            <summary>
            The name of the wrapped parameter. This will be null if the <see cref="P:Animancer.ControllerState.Parameter.Hash"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Parameter.Hash">
            <summary>
            The name hash of the wrapped parameter.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.#ctor(System.String)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Name"/> and uses
            <see cref="M:UnityEngine.Animator.StringToHash(System.String)"/> to calculate the <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.#ctor(System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Hash"/> and leaves the
            <see cref="P:Animancer.ControllerState.Parameter.Name"/> null.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.op_Implicit(System.String)~Animancer.ControllerState.Parameter">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Name"/> and uses
            <see cref="M:UnityEngine.Animator.StringToHash(System.String)"/> to calculate the <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.op_Implicit(System.Int32)~Animancer.ControllerState.Parameter">
            <summary>
            Constructs a new <see cref="T:Animancer.ControllerState.Parameter"/> with the specified <see cref="P:Animancer.ControllerState.Parameter.Hash"/> and leaves the
            <see cref="P:Animancer.ControllerState.Parameter.Name"/> null.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.op_Implicit(Animancer.ControllerState.Parameter)~System.Int32">
            <summary>Returns the <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.Validate(UnityEngine.RuntimeAnimatorController,UnityEngine.AnimatorControllerParameterType)">
            <summary>[Editor-Conditional]
            Throws an <see cref="T:System.ArgumentException"/> if the <see cref="P:Animancer.ControllerState.Controller"/> doesn't have a parameter
            with the specified 'nameHash' and 'type'.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.ControllerState.Parameter.ToString">
            <summary>Returns a string containing the <see cref="P:Animancer.ControllerState.Parameter.Name"/> and <see cref="P:Animancer.ControllerState.Parameter.Hash"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't wrap any parameters.</exception>
        </member>
        <member name="T:Animancer.ControllerState.Serializable`1">
            <summary>
            Base class for serializable objects which can create a particular type of <see cref="T:Animancer.ControllerState"/>
            when passed into <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
            <remarks>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.ControllerState.Serializable`1.Controller">
            <summary>
            The <see cref="P:Animancer.ControllerState.Controller"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Serializable`1.Key">
            <summary>
            The <see cref="P:Animancer.ControllerState.Serializable`1.Controller"/> will be used as the <see cref="P:Animancer.AnimancerState.Key"/> for the created state to be
            registered with.
            </summary>
        </member>
        <member name="T:Animancer.ControllerState.Serializable">
            <summary>
            A serializable object which can create a <see cref="T:Animancer.ControllerState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.Serializable.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ControllerState"/> connected to the 'layer'.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.FloatControllerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.ControllerState"/> which manages a float parameter.
            </summary>
        </member>
        <member name="P:Animancer.FloatControllerState.ParameterName">
            <summary>
            The name of the parameter which <see cref="P:Animancer.FloatControllerState.Parameter"/> will get and set.
            This will be null if the <see cref="P:Animancer.FloatControllerState.ParameterHash"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.FloatControllerState.ParameterHash">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.FloatControllerState.Parameter"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.FloatControllerState.Parameter">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.FloatControllerState.ParameterHash"/> as the id.
            </summary>
        </member>
        <member name="M:Animancer.FloatControllerState.#ctor(Animancer.AnimancerPlayable,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter)">
            <summary>
            Constructs a new <see cref="T:Animancer.FloatControllerState"/> to play the 'controller' without connecting
            it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>. You must call <see cref="!:AnimancerState.SetParent(AnimancerLayer)"/>
            or it won't actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.FloatControllerState.#ctor(Animancer.AnimancerLayer,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter)">
            <summary>
            Constructs a new <see cref="T:Animancer.FloatControllerState"/> to play the 'controller' and connects
            it to the 'layer's <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from
            previously destroyed states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.FloatControllerState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter)">
            <summary>
            Constructs a new <see cref="T:Animancer.FloatControllerState"/> to play the 'controller' and connects
            it to the 'parent's <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="P:Animancer.FloatControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.FloatControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
        </member>
        <member name="T:Animancer.FloatControllerState.Serializable">
            <summary>
            A serializable object which can create a <see cref="T:Animancer.FloatControllerState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Animancer.FloatControllerState.Serializable.ParameterName">
            <summary>
            The <see cref="P:Animancer.FloatControllerState.ParameterName"/> that will be used for the created state.
            </summary>
        </member>
        <member name="M:Animancer.FloatControllerState.Serializable.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.FloatControllerState"/> connected to the 'layer'.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.Vector2ControllerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.ControllerState"/> which manages two float parameters.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.ParameterNameX">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Vector2ControllerState.ParameterX"/> will get and set.
            This will be null if the <see cref="P:Animancer.Vector2ControllerState.ParameterHashX"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.ParameterHashX">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Vector2ControllerState.ParameterX"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.ParameterX">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Vector2ControllerState.ParameterHashX"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.ParameterNameY">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Vector2ControllerState.ParameterY"/> will get and set.
            This will be null if the <see cref="P:Animancer.Vector2ControllerState.ParameterHashY"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.ParameterHashY">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Vector2ControllerState.ParameterY"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.ParameterY">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Vector2ControllerState.ParameterHashY"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.Parameter">
            <summary>
            Gets and sets <see cref="P:Animancer.Vector2ControllerState.ParameterX"/> and <see cref="P:Animancer.Vector2ControllerState.ParameterY"/>.
            </summary>
        </member>
        <member name="M:Animancer.Vector2ControllerState.#ctor(Animancer.AnimancerPlayable,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter)">
            <summary>
            Constructs a new <see cref="T:Animancer.Vector2ControllerState"/> to play the 'controller' without connecting
            it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>. You must call <see cref="!:AnimancerState.SetParent(AnimancerLayer)"/>
            or it won't actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.Vector2ControllerState.#ctor(Animancer.AnimancerLayer,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter)">
            <summary>
            Constructs a new <see cref="T:Animancer.Vector2ControllerState"/> to play the 'controller' and
            connects it to the 'layer's <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from
            previously destroyed states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.Vector2ControllerState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter)">
            <summary>
            Constructs a new <see cref="T:Animancer.Vector2ControllerState"/> to play the 'controller' and
            connects it to the 'parent's <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.Vector2ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
        </member>
        <member name="T:Animancer.Vector2ControllerState.Serializable">
            <summary>
            A serializable object which can create a <see cref="T:Animancer.Vector2ControllerState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.Serializable.ParameterNameX">
            <summary>
            The <see cref="P:Animancer.Vector2ControllerState.ParameterNameX"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.Vector2ControllerState.Serializable.ParameterNameY">
            <summary>
            The <see cref="P:Animancer.Vector2ControllerState.ParameterNameY"/> that will be used for the created state.
            </summary>
        </member>
        <member name="M:Animancer.Vector2ControllerState.Serializable.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.Vector2ControllerState"/> connected to the 'layer'.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.Vector3ControllerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.ControllerState"/> which manages three float parameters.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterNameX">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Vector3ControllerState.ParameterX"/> will get and set.
            This will be null if the <see cref="P:Animancer.Vector3ControllerState.ParameterHashX"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterHashX">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Vector3ControllerState.ParameterX"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterX">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Vector3ControllerState.ParameterHashX"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterNameY">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Vector3ControllerState.ParameterY"/> will get and set.
            This will be null if the <see cref="P:Animancer.Vector3ControllerState.ParameterHashY"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterHashY">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Vector3ControllerState.ParameterY"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterY">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Vector3ControllerState.ParameterHashY"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterNameZ">
            <summary>
            The name of the parameter which <see cref="P:Animancer.Vector3ControllerState.ParameterZ"/> will get and set.
            This will be null if the <see cref="P:Animancer.Vector3ControllerState.ParameterHashZ"/> was assigned directly.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterHashZ">
            <summary>
            The name hash of the parameter which <see cref="P:Animancer.Vector3ControllerState.ParameterZ"/> will get and set.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterZ">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Vector3ControllerState.ParameterHashZ"/> as the id.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.Parameter">
            <summary>
            Gets and sets <see cref="P:Animancer.Vector3ControllerState.ParameterX"/>, <see cref="P:Animancer.Vector3ControllerState.ParameterY"/>, and <see cref="P:Animancer.Vector3ControllerState.ParameterZ"/>.
            </summary>
        </member>
        <member name="M:Animancer.Vector3ControllerState.#ctor(Animancer.AnimancerPlayable,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter)">
            <summary>
            Constructs a new <see cref="T:Animancer.Vector3ControllerState"/> to play the 'controller' without connecting
            it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>. You must call <see cref="!:AnimancerState.SetParent(AnimancerLayer)"/>
            or it won't actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.Vector3ControllerState.#ctor(Animancer.AnimancerLayer,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter)">
            <summary>
            Constructs a new <see cref="T:Animancer.Vector3ControllerState"/> to play the 'controller' and
            connects it to the 'layer's <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from
            previously destroyed states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.Vector3ControllerState.#ctor(Animancer.AnimancerNode,System.Int32,UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter,Animancer.ControllerState.Parameter)">
            <summary>
            Constructs a new <see cref="T:Animancer.Vector3ControllerState"/> to play the 'controller' and
            connects it to the 'parent's <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.Vector3ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
        </member>
        <member name="T:Animancer.Vector3ControllerState.Serializable">
            <summary>
            A serializable object which can create a <see cref="T:Animancer.Vector3ControllerState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.Serializable.ParameterNameX">
            <summary>
            The <see cref="P:Animancer.Vector3ControllerState.ParameterNameX"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.Serializable.ParameterNameY">
            <summary>
            The <see cref="P:Animancer.Vector3ControllerState.ParameterNameY"/> that will be used for the created state.
            </summary>
        </member>
        <member name="P:Animancer.Vector3ControllerState.Serializable.ParameterNameZ">
            <summary>
            The <see cref="P:Animancer.Vector3ControllerState.ParameterNameZ"/> that will be used for the created state.
            </summary>
        </member>
        <member name="M:Animancer.Vector3ControllerState.Serializable.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.Vector3ControllerState"/> connected to the 'layer'.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.IAnimancerComponent">
            <summary>
            Interface for components that manage an <see cref="T:Animancer.AnimancerPlayable"/>.
            </summary>
            <remarks>
            This interface allows Animancer Lite to reference an <see cref="!:AnimancerComponent"/> inside the pre-compiled
            DLL while allowing that component to remain outside as a regular script. Otherwise everything would need to be
            in the DLL which would cause Unity to lose all the script references when upgrading from Animancer Lite to Pro.
            </remarks>
        </member>
        <member name="P:Animancer.IAnimancerComponent.enabled">
            <summary>Indicates whether this component will be updated.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.gameObject">
            <summary>The <see cref="T:UnityEngine.GameObject"/> this component is attached to.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.Animator">
            <summary>The <see cref="T:UnityEngine.Animator"/> component which this script controls.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.Playable">
            <summary>The internal system which manages the playing animations.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.IsPlayableInitialised">
            <summary>Indicates whether the <see cref="P:Animancer.IAnimancerComponent.Playable"/> has been initialised (is not null).</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.UpdateMode">
            <summary>
            Determines when animations are updated and which time source is used. This property is mainly a wrapper
            around the <see cref="P:UnityEngine.Animator.updateMode"/>.
            </summary>
        </member>
        <member name="M:Animancer.IAnimancerComponent.GetOrCreateState(UnityEngine.AnimationClip,System.Int32,System.Boolean)">
            <summary>
            Gets an existing state that plays the 'clip' if there is one. Otherwise creates a new state to play it.
            </summary>
        </member>
        <member name="T:Animancer.IAnimancerTransition">
            <summary>
            An object that can create an <see cref="T:Animancer.AnimancerState"/> and manage the details of how it should be played.
            </summary>
        </member>
        <member name="M:Animancer.IAnimancerTransition.CreateState(Animancer.AnimancerLayer)">
            <summary>Creates and returns a new <see cref="T:Animancer.AnimancerState"/> connected to the 'layer'.</summary>
        </member>
        <member name="P:Animancer.IAnimancerTransition.CrossFadeFromStart">
            <summary>
            When a transition is passed into <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>, this property
            determines whether it needs to fade in from the start of the animation.
            </summary>
        </member>
        <member name="P:Animancer.IAnimancerTransition.FadeDuration">
            <summary>The amount of time the transition should take (in seconds).</summary>
        </member>
        <member name="M:Animancer.IAnimancerTransition.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/> to apply any modifications to the 'state'.
            </summary>
        </member>
        <member name="T:Animancer.IAnimationClipSource">
            <summary>
            Proxy for an identical interface introduced in Unity 2018.3 to have a class provide its own list of
            <see cref="T:UnityEngine.AnimationClip"/>s to the Animation Window without an Animator Controller.
            </summary>
        </member>
        <member name="T:Animancer.IEarlyUpdate">
            <summary>
            Interface for objects that need to be updated earlier than others.
            </summary>
        </member>
        <member name="P:Animancer.IEarlyUpdate.PortIndex">
            <summary>
            The index of the port on the parent's <see cref="!:IAnimationMixer.Playable"/> which this node is connected to.
            <para></para>
            A negative value indicates that it is not assigned to a port.
            </summary>
        </member>
        <member name="M:Animancer.IEarlyUpdate.EarlyUpdate(System.Boolean@)">
            <summary>
            Called by <see cref="T:Animancer.AnimancerPlayable"/> before <see cref="M:Animancer.AnimancerNode.Update(System.Boolean@)"/>.
            </summary>
        </member>
        <member name="T:Animancer.IHasKey">
            <summary>
            Exposes a <see cref="P:Animancer.IHasKey.Key"/> object that can be used for dictionaries and hash sets.
            </summary>
        </member>
        <member name="P:Animancer.IHasKey.Key">
            <summary>
            An identifier object that can be used for dictionaries and hash sets.
            </summary>
        </member>
        <member name="T:Animancer.CartesianMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together based on a two dimensional
            parameter and thresholds using Gradient Band Interpolation.
            <para></para>
            This mixer type is similar to the 2D Freeform Cartesian Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.CartesianMixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            You must call <see cref="!:AnimancerState.SetParent(AnimancerLayer)"/> or it won't actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.CartesianMixerState"/> and connects it to the 'layer's
            <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from previously destroyed
            states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.CartesianMixerState"/> and connects it to the 'parent's
            <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterX">
            <summary>Gets or sets Parameter.x.</summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterY">
            <summary>Gets or sets Parameter.y.</summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.RecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="!:States"/> based on the current value of the
            <see cref="!:Parameter"/> and the <see cref="!:Thresholds"/>.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.AppendParameter(System.Text.StringBuilder)">
            <summary>Appends the current parameter values of this mixer.</summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.CartesianMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.DirectionalMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together based on a two dimensional
            parameter and thresholds using Polar Gradient Band Interpolation.
            <para></para>
            This mixer type is similar to the 2D Freeform Directional Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.DirectionalMixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            You must call <see cref="!:AnimancerState.SetParent(AnimancerLayer)"/> or it won't actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.DirectionalMixerState"/> and connects it to the 'layer's
            <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from previously destroyed
            states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.DirectionalMixerState"/> and connects it to the 'parent's
            <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterX">
            <summary>Gets or sets Parameter.x.</summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterY">
            <summary>Gets or sets Parameter.y.</summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.RecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="!:States"/> based on the current value of the
            <see cref="!:Parameter"/> and the thresholds.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.AppendParameter(System.Text.StringBuilder)">
            <summary>Appends the current parameter values of this mixer.</summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.DirectionalMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.LinearMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together using linear interpolation
            between the specified thresholds.
            <para></para>
            This mixer type is similar to the 1D Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            You must call <see cref="!:AnimancerState.SetParent(AnimancerLayer)"/> or it won't actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> and connects it to the 'layer's
            <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from previously destroyed
            states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> and connects it to the 'parent's
            <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Initialise(UnityEngine.AnimationClip[],System.Single,System.Single)">
            <summary>
            Initialises the <see cref="!:Mixer"/> and <see cref="!:States"/> with one state per clip and assigns thresholds
            evenly spaced between the specified min and max (inclusive).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Initialise(UnityEngine.AnimationClip,UnityEngine.AnimationClip,System.Single,System.Single)">
            <summary>
            Initialises the <see cref="!:Mixer"/> with two ports and connects two states to them for the specified clips
            at the specified thresholds (default 0 and 1).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Initialise(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip,System.Single,System.Single,System.Single)">
            <summary>
            Initialises the <see cref="!:Mixer"/> with three ports and connects three states to them for the specified
            clips at the specified thresholds (default -1, 0, and 1).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AssertThresholdsSorted">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> unless the thresholds are sorted from lowest to highest.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.LinearMixerState.RecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="!:States"/> based on the current value of the
            <see cref="!:Parameter"/> and the thresholds.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AssignLinearThresholds(System.Single,System.Single)">
            <summary>
            Assigns the <see cref="!:Thresholds"/> to be evenly spaced between the specified min and max (inclusive).
            </summary>
        </member>
        <member name="P:Animancer.LinearMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.LinearMixerState.Serializable">
            <summary>
            A serializable object which can create a <see cref="T:Animancer.LinearMixerState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Serializable.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.LinearMixerState"/> connected to the 'layer'.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.ManualMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends multiple child states. Unlike other mixers, this class does not
            perform any automatic weight calculations, it simple allows you to control the weight of all states manually.
            <para></para>
            This mixer type is similar to the Direct Blend Type in Mecanim Blend Trees.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.States">
            <summary>The states managed by this mixer.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.PortCount">
            <summary>The number of input ports in the <see cref="!:Mixer"/>.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.ChildStates">
            <summary>Returns the <see cref="P:Animancer.ManualMixerState.States"/> array.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            You must call <see cref="!:AnimancerState.SetParent(AnimancerLayer)"/> or it won't actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> and connects it to the 'layer's
            <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from previously destroyed
            states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.LinearMixerState"/> and connects it to the 'parent's
            <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Initialise(System.Int32)">
            <summary>
            Initialises this mixer with the specified number of ports which can be filled individually by <see cref="M:Animancer.ManualMixerState.CreateState(System.Int32,UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Initialise(UnityEngine.AnimationClip[])">
            <summary>
            Initialises this mixer with one state per clip.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.CreateState(System.Int32,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the 'clip' with this
            <see cref="T:Animancer.MixerState"/> as its parent.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.OnAddChild(Animancer.AnimancerState)">
            <summary>Connects the 'state' to this mixer at its <see cref="P:Animancer.AnimancerNode.PortIndex"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.OnRemoveChild(Animancer.AnimancerState)">
            <summary>Disconnects the 'state' from this mixer at its <see cref="P:Animancer.AnimancerNode.PortIndex"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Dispose">
            <summary>
            Destroys the <see cref="T:UnityEngine.Playables.Playable"/> of this mixer and its <see cref="P:Animancer.ManualMixerState.States"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.DestroyChildren">
            <summary>
            Destroys all <see cref="P:Animancer.ManualMixerState.States"/> connected to this mixer. This operation cannot be undone.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.RecalculateWeights">
            <summary>
            Does nothing. Manual mixers don't automatically recalculate their weights.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.DisableRemainingStates(System.Int32)">
            <summary>
            Sets the weight of all states after the 'previousIndex' to 0.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.GetNextState(System.Int32@)">
            <summary>
            Returns the state at the specified 'index' if it isn't null, otherwise increments the index and checks
            again. Returns null if no state is found by the end of the <see cref="P:Animancer.ManualMixerState.States"/> array.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.NormalizeWeights(System.Single)">
            <summary>
            Divides the weight of all states by the 'totalWeight' so that they all add up to 1.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Gets a user-friendly key to identify the 'state' in the inspector.</summary>
        </member>
        <member name="T:Animancer.ManualMixerState.Serializable`1">
            <summary>
            Base class for serializable objects which can create a particular type of <see cref="T:Animancer.ManualMixerState"/>
            when passed into <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
            <remarks>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.ManualMixerState.Serializable`1.Clips">
            <summary>
            The <see cref="P:Animancer.ClipState.Clip"/> to use for each state in the mixer.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Serializable`1.Speeds">
            <summary>
            The <see cref="P:Animancer.AnimancerState.Speed"/> to use for each state in the mixer.
            <para></para>
            If the size of this array doesn't match the <see cref="P:Animancer.ManualMixerState.Serializable`1.Clips"/>, it will be ignored.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Serializable`1.InitialiseState">
            <summary>
            Initialises the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/> immediately after it is created.
            </summary>
        </member>
        <member name="T:Animancer.ManualMixerState.Serializable">
            <summary>
            A serializable object which can create a <see cref="T:Animancer.ManualMixerState"/> when passed into
            <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Serializable.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ManualMixerState"/> connected to the 'layer'.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.MixerState">
            <summary>[Pro-Only]
            Base class for <see cref="T:Animancer.AnimancerState"/>s which blend other states together.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.PortCount">
            <summary>The number of input ports in the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.MixerState.KeepChildrenConnected">
            <summary>Mixers should keep child playables connected to the graph at all times.</summary>
        </member>
        <member name="P:Animancer.MixerState.Clip">
            <summary>An <see cref="T:Animancer.MixerState"/> has no <see cref="T:UnityEngine.AnimationClip"/>.</summary>
        </member>
        <member name="P:Animancer.MixerState.ChildStates">
            <summary>
            Returns the collection of states connected to this mixer. Note that some elements may be null.
            <para></para>
            Getting an enumerator that automatically skips over null states is slower and creates garbage, so
            internally we use this property and perform null checks manually even though it increases the code
            complexity a bit.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.GetEnumerator">
            <summary>
            Returns an enumerator through each state connected to this mixer.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.IsPlaying">
            <summary>
            Determines whether the clips in this mixer are playing.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.Time">
            <summary>
            The current local time of this state in seconds.
            Setting this property passes the value onto all <see cref="P:Animancer.MixerState.ChildStates"/>.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.OnEnd">
            <summary>
            <see cref="T:Animancer.MixerState"/>s don't track the progress of a single animation so this event isn't
            used and will be ignored.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.AddOnEndEventToChildren(System.Action)">
            <summary>
            Adds the 'callback' to the <see cref="P:Animancer.AnimancerState.OnEnd"/> events of all child states.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.RemoveOnEndEventFromChildren(System.Action)">
            <summary>
            Removes the 'callback' from the <see cref="P:Animancer.AnimancerState.OnEnd"/> events of all child states.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.AreWeightsDirty">
            <summary>Indicates whether the weights of all child states should be recalculated.</summary>
        </member>
        <member name="M:Animancer.MixerState.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            You must call <see cref="!:AnimancerState.SetParent(AnimancerLayer)"/> or it won't actually do anything.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState"/> and connects it to the 'layer's
            <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from previously destroyed
            states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState"/> and connects it to the 'parent's
            <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.CreateState(System.Int32,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the 'clip' with this
            <see cref="T:Animancer.MixerState"/> as its parent.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ChildCount">
            <summary>The number of states using this mixer as their <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState.GetChild(System.Int32)">
            <summary>
            Returns the state connected to the specified 'portIndex' as a child of this mixer.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.RecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="!:States"/> based on the current value of the
            <see cref="!:Parameter"/> and the <see cref="!:Thresholds"/>.
            <para></para>
            Overrides of this method must set <see cref="P:Animancer.MixerState.AreWeightsDirty"/> = false.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ApplyAnimatorIK">
            <summary>
            Determines whether <c>OnAnimatorIK(int layerIndex)</c> will be called on the animated object for any
            <see cref="P:Animancer.MixerState.ChildStates"/>.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyAnimatorIK"/>.
            <para></para>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers.
            <para></para>
            It requires Unity 2018.1 or newer, however 2018.3 or newer is recommended because a bug in earlier versions
            of the Playables API caused this value to only take effect while a state was at
            <see cref="P:Animancer.AnimancerNode.Weight"/> == 1 which meant that IK would not work while fading between animations.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ApplyFootIK">
            <summary>
            Indicates whether any of the <see cref="P:Animancer.MixerState.ChildStates"/> in this mixer are applying IK to the character's feet.
            The initial value is determined by <see cref="P:Animancer.AnimancerLayer.DefaultApplyFootIK"/>.
            <para></para>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="M:Animancer.MixerState.NormalizeDurations">
            <summary>
            Recalculates the <see cref="P:Animancer.AnimancerState.Duration"/> of all child states so that they add up to 1.
            </summary>
            <exception cref="T:System.NullReferenceException">Thrown if there are any states with no <see cref="P:Animancer.MixerState.Clip"/>.</exception>
        </member>
        <member name="M:Animancer.MixerState.HasEvent(System.String)">
            <summary>Checks if any of this mixer's children has an animation event with the specified 'functionName'.</summary>
        </member>
        <member name="M:Animancer.MixerState.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Gets a user-friendly key to identify the 'state' in the inspector.</summary>
        </member>
        <member name="M:Animancer.MixerState.ToString">
            <summary>
            Returns a string describing the type of this mixer and the name of <see cref="P:Animancer.MixerState.Clip"/>s connected to it.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipSource"/>]
            Gathers all the animations associated with this state.
            </summary>
        </member>
        <member name="P:Animancer.MixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.MixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.MixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">Thrown if this state doesn't manage any parameters.</exception>
        </member>
        <member name="T:Animancer.MixerState.Serializable`2">
            <summary>
            Base class for serializable objects which can create a particular type of
            <see cref="T:Animancer.MixerState`1"/> when passed into <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
            <remarks>
            Even though it has the <see cref="T:System.SerializableAttribute"/>, this class won't actually get serialized
            by Unity because it's generic and abstract. Each child class still needs to include the attribute.
            </remarks>
        </member>
        <member name="P:Animancer.MixerState.Serializable`2.Thresholds">
            <summary>The parameter values at which each of the states are used and blended.</summary>
        </member>
        <member name="P:Animancer.MixerState.Serializable`2.DefaultParameter">
            <summary>The initial parameter value to give the mixer when it is first created.</summary>
        </member>
        <member name="M:Animancer.MixerState.Serializable`2.InitialiseState">
            <summary>
            Initialises the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/> immediately after it is created.
            </summary>
        </member>
        <member name="T:Animancer.MixerState.Serializable2D">
            <summary>
            A serializable object which can create a <see cref="T:Animancer.CartesianMixerState"/> or
            <see cref="T:Animancer.DirectionalMixerState"/> when passed into <see cref="M:Animancer.AnimancerPlayable.Transition(Animancer.IAnimancerTransition,System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Animancer.MixerState.Serializable2D.MixerType">
            <summary>
            A type of <see cref="T:Animancer.MixerState"/> that can be created by a <see cref="T:Animancer.MixerState.Serializable2D"/>.
            </summary>
        </member>
        <member name="F:Animancer.MixerState.Serializable2D.MixerType.Cartesian">
            <summary><see cref="T:Animancer.CartesianMixerState"/></summary>
        </member>
        <member name="F:Animancer.MixerState.Serializable2D.MixerType.Directional">
            <summary><see cref="T:Animancer.DirectionalMixerState"/></summary>
        </member>
        <member name="P:Animancer.MixerState.Serializable2D.Type">
            <summary>
            The type of <see cref="T:Animancer.MixerState"/> that this serializable will create.
            </summary>
        </member>
        <member name="M:Animancer.MixerState.Serializable2D.CreateState(Animancer.AnimancerLayer)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.CartesianMixerState"/> or <see cref="T:Animancer.DirectionalMixerState"/>
            depending on the <see cref="P:Animancer.MixerState.Serializable2D.Type"/> connected to the 'layer'.
            <para></para>
            This method also assigns it as the <see cref="P:Animancer.AnimancerState.Serializable`1.State"/>.
            </summary>
        </member>
        <member name="T:Animancer.MixerState`1">
            <summary>[Pro-Only]
            Base class for <see cref="T:Animancer.MixerState"/>s which blend an array of <see cref="!:States"/> together based on a
            <see cref="P:Animancer.MixerState`1.Parameter"/>.
            </summary>
        </member>
        <member name="F:Animancer.MixerState`1._Thresholds">
            <summary>The parameter values at which each of the <see cref="!:States"/> are used and blended.</summary>
        </member>
        <member name="P:Animancer.MixerState`1.Parameter">
            <summary>The value used to calculate the weights of the <see cref="!:States"/>.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.HasThresholds">
            <summary>
            Returns true if the thresholds array is not null.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.GetThreshold(System.Int32)">
            <summary>
            Returns the value of the threshold associated with the specified portIndex.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.SetThreshold(System.Int32,`0)">
            <summary>
            Sets the value of the threshold associated with the specified portIndex.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.SetThresholds(`0[])">
            <summary>
            Assigns the specified array as the thresholds to use for blending.
            <para></para>
            WARNING: if you keep a reference to the 'thresholds' array you must call <see cref="M:Animancer.MixerState`1.OnThresholdsChanged"/>
            whenever any changes are made to it, otherwise this mixer may not blend correctly.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.ValidateThresholdCount">
            <summary>
            If the <see cref="F:Animancer.MixerState`1._Thresholds"/> don't have the same <see cref="P:System.Array.Length"/> as the
            <see cref="!:States"/>, this method allocates and assigns a new array of that size.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. By default this method simply indicates that the blend weights
            need recalculating but it can be overridden by child classes to perform validation checks or optimisations.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.CalculateThresholds(System.Func{Animancer.AnimancerState,`0})">
            <summary>
            Calls 'calculate' for each of the <see cref="!:States"/> and stores the returned value as the threshold for
            that state.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.#ctor(Animancer.AnimancerPlayable)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState`1"/> without connecting it to the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            You must call <see cref="!:AnimancerState.SetParent(AnimancerLayer)"/> or it won't actually doanything.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.#ctor(Animancer.AnimancerLayer)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState`1"/> and connects it to the 'layer's
            <see cref="!:IAnimationMixer.Playable"/> using a spare port if there are any from previously destroyed
            states, or by adding a new port.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.#ctor(Animancer.AnimancerNode,System.Int32)">
            <summary>
            Constructs a new <see cref="T:Animancer.MixerState`1"/> and connects it to the 'parent's
            <see cref="!:IAnimationMixer.Playable"/> at the specified 'portIndex'.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Initialise(System.Int32)">
            <summary>
            Initialises this mixer with the specified number of ports which can be filled individually by <see cref="M:Animancer.MixerState`1.CreateState(System.Int32,UnityEngine.AnimationClip,`0)"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Initialise(UnityEngine.AnimationClip[],`0[])">
            <summary>
            Initialises the <see cref="!:Mixer"/> and <see cref="!:States"/> with one state per clip and assigns the
            'thresholds'.
            <para></para>
            WARNING: if the caller keeps a reference to the 'thresholds' array, it must call
            <see cref="M:Animancer.MixerState`1.OnThresholdsChanged"/> whenever any changes are made to it, otherwise this mixer may not blend
            correctly.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Initialise(UnityEngine.AnimationClip[],System.Func{Animancer.AnimancerState,`0})">
            <summary>
            Initialises the <see cref="!:Mixer"/> and <see cref="!:States"/> with one state per clip and assigns the
            thresholds by calling 'calculateThreshold' for each state.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.CreateState(System.Int32,UnityEngine.AnimationClip,`0)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the 'clip' with this
            <see cref="T:Animancer.MixerState"/> as its parent, connects it to the specified 'portIndex', and assigns the
            'threshold' for it.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Gets a user-friendly key to identify the 'state' in the inspector.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.AppendDescription(System.Text.StringBuilder,System.Boolean,System.Boolean,System.String)">
            <summary>Appends a detailed descrption of the current details of this state.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.AppendParameter(System.Text.StringBuilder)">
            <summary>Appends the current parameter value of this mixer.</summary>
        </member>
        <member name="T:Animancer.SoloAnimationInternal">
            <summary>Plays a single <see cref="T:UnityEngine.AnimationClip"/> on startup.</summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Animator">
            <summary>
            The <see cref="T:UnityEngine.Animator"/> component which this script controls.
            <para></para>
            If you need to set this value at runtime you are likely better off using a proper
            <see cref="!:AnimancerComponent"/>.
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Clip">
            <summary>
            The <see cref="T:UnityEngine.AnimationClip"/> which will be played by <see cref="M:Animancer.SoloAnimationInternal.OnEnable"/>.
            <para></para>
            If you need to set this value at runtime you are likely better off using a proper
            <see cref="!:AnimancerComponent"/>.
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.StopOnDisable">
            <summary>
            If true, disabling this object will stop and rewind the animation. Otherwise it will simply be paused
            and will resume from its current state when it is re-enabled.
            <para></para>
            The default value is true.
            <para></para>
            This property wraps <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> and inverts its value.
            The value is serialized by the <see cref="T:UnityEngine.Animator"/>.
            <para></para>
            It requires Unity 2018.1 or newer.
            </summary>
        </member>
        <member name="F:Animancer.SoloAnimationInternal._Graph">
            <summary>
            The <see cref="T:UnityEngine.Playables.PlayableGraph"/> being used to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.
            </summary>
        </member>
        <member name="F:Animancer.SoloAnimationInternal._Playable">
            <summary>
            The <see cref="T:UnityEngine.Animations.AnimationClipPlayable"/> being used to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.IsPlaying">
            <summary>
            Indicates whether the animation is playing (true) or paused (false).
            </summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Speed">
            <summary>
            The speed at which the animation is playing (default 1).
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if this component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.FootIK">
            <summary>
            Determines whether Foot IK will be applied to the model (if it is Humanoid).
            <para></para>
            The developers of Unity have states that they believe it looks better with this enabled, but more often
            than not it just makes the legs end up in a slightly different pose to what the animator intended.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if this component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Time">
            <summary>
            The number of seconds that have passed since the start of the animation.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if this component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.NormalizedTime">
            <summary>
            The <see cref="P:Animancer.SoloAnimationInternal.Time"/> of this state as a portion of the <see cref="P:UnityEngine.AnimationClip.length"/>, meaning the
            value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes.
            <para></para>
            This value will continue increasing after the animation passes the end of its length and it will either
            freeze in place or start again from the beginning according to whether it is looping or not.
            <para></para>
            The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the
            current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has
            been looped.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if this component is not yet <see cref="M:Animancer.SoloAnimationInternal.Awake"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.IsInitialised">
            <summary>Indicates whether the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is valid.</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Awake">
            <summary>
            Called by Unity when this component is first created.
            <para></para>
            Initialises everything needed to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnEnable">
            <summary>
            Called by Unity when this component becomes enabled and active.
            <para></para>
            Plays the <see cref="P:Animancer.SoloAnimationInternal.Clip"/> on the target <see cref="P:Animancer.SoloAnimationInternal.Animator"/>.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Update">
            <summary>
            Called by Unity every frame while this component is enabled and active.
            <para></para>
            Checks if the animation is done so it can pause the <see cref="T:UnityEngine.Playables.PlayableGraph"/> to improve performance.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnDisable">
            <summary>
            Called by Unity when this component becomes disabled or inactive.
            <para></para>
            Ensures that the <see cref="F:Animancer.SoloAnimationInternal._Graph"/> is properly cleaned up.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnDestroy">
            <summary>
            Called by Unity when this component is destroyed.
            <para></para>
            Ensures that the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is properly cleaned up.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipSource"/>]
            Adds the <see cref="P:Animancer.SoloAnimationInternal.Clip"/> to the list.
            </summary>
        </member>
    </members>
</doc>
